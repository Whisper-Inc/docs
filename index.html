<!DOCTYPE html>
<!--[if lt IE 7]><html class="ie ie6" lang="en"> <![endif]-->
<!--[if IE 7]><html class="ie ie7" lang="en"> <![endif]-->
<!--[if IE 8]><html class="ie ie8" lang="en"> <![endif]-->
<!--[if (gte IE 9)|!(IE)]><!-->
<html lang="en">
  <!--<![endif]-->

  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1"
    />
    <meta name="description" content="" />
    <meta name="author" content="" />
    <meta name="keywords" content="" />

    <title>Whisper Docs</title>

    <link rel="shortcut icon" href="images/favicon.webp" type="image/x-icon" />

    <link
      rel="stylesheet"
      type="text/css"
      href="fonts/font-awesome-4.3.0/css/font-awesome.min.css"
    />
    <link rel="stylesheet" type="text/css" href="css/stroke.css" />
    <link rel="stylesheet" type="text/css" href="css/bootstrap.css" />
    <link rel="stylesheet" type="text/css" href="css/animate.css" />
    <link rel="stylesheet" type="text/css" href="css/prettyPhoto.css" />
    <link rel="stylesheet" type="text/css" href="css/style.css" />

    <link
      rel="stylesheet"
      type="text/css"
      href="js/syntax-highlighter/styles/shCore.css"
      media="all"
    />
    <link
      rel="stylesheet"
      type="text/css"
      href="js/syntax-highlighter/styles/shThemeRDark.css"
      media="all"
    />

    <!-- CUSTOM -->
    <link rel="stylesheet" type="text/css" href="css/custom.css" />

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>

  <body>
    <button onclick="topFunction()" id="myBtn" title="Go to top">
      <i class="fa fa-chevron-up" aria-hidden="true"></i>
    </button>

    <script>
      var mybutton = document.getElementById("myBtn");
      window.onscroll = function () {
        scrollFunction();
      };
      function scrollFunction() {
        if (
          document.body.scrollTop > 1000 ||
          document.documentElement.scrollTop > 1000
        ) {
          mybutton.style.display = "block";
        } else {
          mybutton.style.display = "none";
        }
      }
      function topFunction() {
        window.scrollTo({ top: 0, behavior: "smooth" });
        document.documentElement.scrollTo({ top: 0, behavior: "smooth" });
      }

      document.addEventListener("DOMContentLoaded", () => {
        document.querySelector("#mode").addEventListener("click", () => {
          document.querySelector("html").classList.toggle("dark");
        });
      });
    </script>

    <div id="wrapper">
      <div id="mode">
        <div class="dark">
          <svg aria-hidden="true" viewBox="0 0 512 512">
            <title>lightmode</title>
            <path
              fill="currentColor"
              d="M256 160c-52.9 0-96 43.1-96 96s43.1 96 96 96 96-43.1 96-96-43.1-96-96-96zm246.4 80.5l-94.7-47.3 33.5-100.4c4.5-13.6-8.4-26.5-21.9-21.9l-100.4 33.5-47.4-94.8c-6.4-12.8-24.6-12.8-31 0l-47.3 94.7L92.7 70.8c-13.6-4.5-26.5 8.4-21.9 21.9l33.5 100.4-94.7 47.4c-12.8 6.4-12.8 24.6 0 31l94.7 47.3-33.5 100.5c-4.5 13.6 8.4 26.5 21.9 21.9l100.4-33.5 47.3 94.7c6.4 12.8 24.6 12.8 31 0l47.3-94.7 100.4 33.5c13.6 4.5 26.5-8.4 21.9-21.9l-33.5-100.4 94.7-47.3c13-6.5 13-24.7.2-31.1zm-155.9 106c-49.9 49.9-131.1 49.9-181 0-49.9-49.9-49.9-131.1 0-181 49.9-49.9 131.1-49.9 181 0 49.9 49.9 49.9 131.1 0 181z"
            ></path>
          </svg>
        </div>
        <div class="light">
          <svg aria-hidden="true" viewBox="0 0 512 512">
            <title>darkmode</title>
            <path
              fill="currentColor"
              d="M283.211 512c78.962 0 151.079-35.925 198.857-94.792 7.068-8.708-.639-21.43-11.562-19.35-124.203 23.654-238.262-71.576-238.262-196.954 0-72.222 38.662-138.635 101.498-174.394 9.686-5.512 7.25-20.197-3.756-22.23A258.156 258.156 0 0 0 283.211 0c-141.309 0-256 114.511-256 256 0 141.309 114.511 256 256 256z"
            ></path>
          </svg>
        </div>
      </div>

      <div class="container">
        <section id="top" class="section docs-heading">
          <div class="row">
            <div class="col-md-12">
              <div class="big-title text-center">
                <h1>Whisper Docs</h1>
                <p class="lead">Documentation version 1.0</p>
              </div>
              <!-- end title -->
            </div>
            <!-- end 12 -->
          </div>
          <!-- end row -->

          <hr />
        </section>
        <!-- end section -->

        <div class="row">
          <div class="col-md-3">
            <nav
              class="docs-sidebar"
              data-spy="affix"
              data-offset-top="300"
              data-offset-bottom="200"
              role="navigation"
            >
              <ul class="nav">
                <li>
                  <a href="#line-1">Introduction</a>
                </li>
                <li>
                  <a href="#line0">Team & Decisions</a>
                  <ul class="nav">
                    <li><a href="#line0_1">Role Definition</a></li>
                    <li><a href="#line0_2">Collaboration & Leadership</a></li>
                    <li><a href="#line0_3">Design Choices</a></li>
                  </ul>
                </li>
                <li><a href="#line1">Analysis</a></li>
                <li>
                  <a href="#line4">UI Development</a>
                  <ul class="nav">
                    <li><a href="#line4_1">Inital Components</a></li>
                    <li><a href="#line4_2">Integrating with Backend</a></li>
                    <li>
                      <a href="#line4_3">Login</a>
                    </li>
                    <li>
                      <a href="#line4_4">Frontend UI Refresh</a>
                    </li>
                  </ul>
                </li>
                <li>
                  <a href="#line6">Database</a>
                  <ul class="nav">
                    <li><a href="#line6_1">Setup</a></li>
                    <li><a href="#line6_2">UserManager</a></li>
                    <li><a href="#line6_3">Endpoints</a></li>
                  </ul>
                </li>
                <li>
                  <a href="#line7">Full-Stack Integration</a>
                </li>
                <li>
                  <a href="#line8">Writing Tests</a>
                  <ul class="nav">
                    <li><a href="#line8_1">Unit Tests</a></li>
                    <li><a href="#line8_2">Frontend Testing</a></li>
                    <li><a href="#line8_3">Integration Tests</a></li>
                    <li><a href="#line8_4">How to Run the Tests</a></li>
                  </ul>
                </li>
                <li>
                  <a href="#line9">Deployment</a>
                  <ul class="nav">
                    <li><a href="#line9_1">Dockerisation</a></li>
                    <li><a href="#line9_2">Pushing to ECR</a></li>
                    <li><a href="#line9_3">Deploying on ECS</a></li>
                    <li><a href="#line9_4">Reference</a></li>
                  </ul>
                </li>
                <li><a href="#line10">CI/CD</a></li>
                <li><a href="#line11">Looking Forward</a></li>
              </ul>
            </nav>
          </div>
          <div class="col-md-9">
            <section class="welcome">
              <div class="row">
                <div class="col-md-12 left-align">
                  <h2 class="dark-text" id="line-1">
                    Introduction
                    <hr />
                  </h2>
                  <div class="row">
                    <div class="col-md-12 full">
                      <div class="intro1">
                        <ul>
                          <li>
                            <strong>Authors : </strong>
                            Jamie Wells, Syed Abbas, Mahbubur Rahman, Samuel
                            Gagatek
                          </li>
                          <li>
                            <strong>License : </strong>
                            MIT
                          </li>
                        </ul>
                      </div>

                      <hr />
                      <div>
                        <h4>Welcome to Whisper!</h4>
                        <strong>What is Whisper?</strong>
                        <p>
                          Whisper is a lightweight messaging service designed
                          with scalability in mind above all else. We have built
                          Whisper with the intention of adding new features in
                          the future, but this documentation will cover the
                          basics of how we went from zero to a public MVP.
                        </p>
                      </div>
                    </div>
                  </div>
                  <!-- end row -->
                </div>
              </div>
            </section>

            <section id="line0" class="section">
              <div class="row">
                <div class="col-md-12 left-align">
                  <h2 class="dark-text">
                    Team and Decisions
                    <p>Samuel Gagatek</p>
                    <hr />
                  </h2>
                  <h3 id="line0_1">Role Definitions</h3>

                  <h4>Jamie Wells: Project Lead</h4>
                  <p>
                    Jamie, the team lead, is responsible for defining the
                    project scope, delegating tasks, and maintaining overall
                    project direction. In addition to leadership duties, he
                    contributed to the project setup, configuration, and backend
                    development.
                  </p>

                  <h4>Syed Abbas: UI/UX & Backend Integration</h4>
                  <p>
                    Syed focused primarily on frontend development, working on
                    React-based UI components while also configuring API
                    endpoints to bridge frontend and backend functionality.
                  </p>

                  <h4>
                    Mahbubur Rahman: Full Stack - Authentication & Integration
                  </h4>
                  <p>
                    Contributing across both backend and frontend, Hysam
                    concentrated on the user authentication flow, including
                    login, registration and websocket functionality, ensuring
                    secure and instant access to the system. Mahbubur also took the lead on our enterprise services.
                  </p>

                  <h4>Samuel Gagatek: Backend & Testing</h4>
                  <p>
                    Samuel worked mainly on backend logic and was instrumental
                    in implementing and running automated tests across both our core and client services. This ensured
                    the stability of the codebase through the usage of both unit and integration
                    testing.
                  </p>

                  <h4 id="line0_2">Collaboration & Leadership</h4>
                  <h4>GitHub Scrum Board</h4>
                  <p>
                    We used a GitHub scrum board to effectively delegate and
                    manage tasks across our team. Each sprint was organized into
                    clear milestones with tracked progress, ensuring alignment
                    and accountability.
                  </p>

                  <h4>Sprint 1: Project Setup & Architecture</h4>
                  <img
                    src="images/upload/Kanban_Board_Sprint_1.png"
                    alt="Sprint 1 image"
                    style="max-width: 800px; width: 100%; height: auto"
                  />
                  <p>
                    In Sprint 1, we focused on laying the foundation of the
                    project. This included setting up the repositories, CI/CD
                    pipeline, database configuration and defining our tech stack
                    across core and client services.
                  </p>

                  <h4>Sprint 2: Core Feature Development & Testing</h4>
                  <img
                    src="images/upload/Kanban_Board_Sprint_2.png"
                    alt="Sprint
                  2 image"
                    style="max-width: 800px; width: 100%; height: auto"
                  />
                  <p>
                    During Sprint 2, we built out major features like
                    authentication, chat creation, and message handling. The
                    team worked across backend, frontend, and we added unit and
                    integration tests to ensure the code was maintainable.
                  </p>

                  <h4>Sprint 3: Documentation & Polishing</h4>
                  <img
                    src="images/upload/Kanban_Board_Sprint_3.png"
                    alt="Sprint
                  3 image"
                    style="max-width: 800px; width: 100%; height: auto"
                  />
                  <p>
                    Sprint 3 focused on testing, bug fixes, and refining UX. We
                    also fully completed our documentation for future reference.
                  </p>

                  <h4>Sprint 4: Building out more features</h4>
                  <img
                    src="images/upload/Kanban_Board_Sprint_4.png"
                    alt="Sprint
                  4 image"
                    style="max-width: 800px; width: 100%; height: auto"
                  />
                  <p>
                    Sprint 4 will focus on expanding our project with more
                    features that make the service more usable.
                  </p>

                  <h4 id="line0_2">Weekly Sprint Planning Meetings</h4>
                  <img
                    src="images/upload/Whisper_Weekly_Zoom.png"
                    alt="Zoom Meeting image"
                    style="max-width: 800px; width: 100%; height: auto"
                  />
                  <p>
                    Each week, our team held structured sprint planning meetings
                    over Zoom to coordinate efforts and keep the project on
                    track. These meetings played a crucial role in our
                    collaborative workflow and typically included the following:
                  </p>

                  <ul>
                    <li>
                      <strong>Review of previous sprint:</strong> Discussed
                      completed tasks, unresolved issues, and any blockers faced
                      by the team.
                    </li>
                    <li>
                      <strong>Task assignment:</strong> Delegated new tasks
                      based on availability, expertise, and interest, ensuring
                      balanced workloads.
                    </li>
                    <li>
                      <strong>Scrum board updates:</strong> Moved cards across
                      columns (To Do, In Progress, Done) and added new issues or
                      features to track.
                    </li>
                    <li>
                      <strong>Technical discussions:</strong> Talked through
                      implementation plans, design decisions, or architectural
                      considerations.
                    </li>
                    <li>
                      <strong>Goal setting:</strong> Aligned on priorities and
                      deliverables for the upcoming sprint to maintain focus and
                      momentum.
                    </li>
                  </ul>

                  <p>
                    These meetings promoted transparency, allowed for real-time
                    collaboration, and helped the team stay synchronized
                    throughout the development process.
                  </p>

                  <h4 id="line0_3">Code Reviews & Collaboration</h4>
                  <img
                    src="images/upload/2_approvals_merge.png"
                    alt="Approve and Merge image"
                    style="max-width: 800px; width: 100%; height: auto"
                  />
                  <p>
                    Our team emphasized the importance of code reviews as a key
                    part of our development workflow. Every pull request was
                    reviewed by at least two other team members before being
                    merged into the main branch. This not only helped catch bugs
                    early but also ensured consistency in code quality, style,
                    and design decisions across the project.
                  </p>
                  <img
                    src="images/upload/PR_comments.png"
                    alt="PR comments image"
                    style="max-width: 800px; width: 100%; height: auto"
                  />
                  <p>
                    Code reviews provided a valuable opportunity for team
                    members to:
                  </p>
                  <ul>
                    <li>
                      <strong>Share knowledge:</strong> Reviewing each other's
                      code helped everyone stay familiar with different parts of
                      the codebase.
                    </li>
                    <li>
                      <strong>Maintain consistency:</strong> We followed
                      agreed-upon conventions and design patterns, which were
                      reinforced during review.
                    </li>
                    <li>
                      <strong>Improve code quality:</strong> Suggestions and
                      feedback often led to better performance, readability, and
                      maintainability.
                    </li>
                    <li>
                      <strong>Encourage collaboration:</strong> Discussions in
                      review threads fostered healthy team communication and
                      problem-solving.
                    </li>
                  </ul>

                  <p>
                    We used GitHub's pull request system to manage reviews,
                    assign reviewers, and track changes. This workflow ensured
                    that all team members were engaged in each other's work and
                    contributed to the overall quality of the project.
                  </p>

                  <h4 id="line0_3">Design Choices</h4>
                  <h4>Whisper Inc Organisation - Our Repositories</h4>

                  <h5>Whisper Core</h5>
                  <p>
                    Whisper Core is the repository that houses the backend of
                    our service. It handles authentication, chat logic, data
                    storage, and API endpoints for client communication.
                  </p>

                  <h5>Whisper Client</h5>
                  <p>
                    Whisper Client is the frontend application used by users to
                    interact with the platform. Built with modern frameworks, it
                    provides real-time messaging with individuals and groups,
                    all while maintaining a modern and sleek user interface.
                  </p>

                  <h5>Docs</h5>
                  <p>
                    Docs is the documentation hub for Whisper Inc. It contains
                    developer guides, API references and architecture overviews
                    to help team members navigate the codebase.
                  </p>

                  <h4 id="line0_2">Why We Chose Python</h4>
                  <p>
                    We chose Python for our backend development due to its
                    simplicity, readability, and wide adoption in web
                    development. Python's vast ecosystem of libraries,
                    particularly for APIs and database management, allowed us to
                    move quickly and build a solid backend foundation. Its clean
                    syntax made collaboration between team members easy,
                    especially when developing or reviewing code.
                  </p>

                  <h4 id="line0_3">Why We Chose React</h4>
                  <p>
                    On the frontend, we selected React because of its
                    component-based architecture, responsive rendering, and
                    strong developer community. React allowed us to break down
                    the UI into reusable, maintainable components that made the
                    app easier to scale and test. Its seamless integration with
                    modern styling libraries and state management tools also
                    helped speed up development and enhance user experience.
                  </p>

                  <h4 id="line0_4">Why We Chose MongoDB</h4>
                  <p>
                    We selected MongoDB as our database solution due to its
                    developer-friendly features and seamless integration with
                    Python. The PyMongo API made it easy to interact with the
                    database using native Python syntax, which reduced
                    complexity and sped up backend development. Additionally,
                    MongoDB's lightweight, schema-less structure allowed us to
                    iterate on our data models quickly without worrying about
                    rigid table definitions. The clean and intuitive user
                    interface provided by MongoDB Atlas also made it easy to
                    visualize, manage, and debug data during development.
                  </p>

                  <h4 id="line0_5">Why We Chose FastAPI Over Flask</h4>
                  <p>
                    We chose FastAPI for our backend framework instead of Flask
                    primarily due to its built-in support for asynchronous
                    request handling, which enables better performance and
                    scalability. FastAPI's use of modern Python features like
                    type hints and Pydantic models helped us write more robust,
                    self-validating code while improving code clarity and
                    autocompletion.
                  </p>
                </div>
                <!-- end col -->
              </div>
            </section>
            <!-- end section -->

            <section id="line1" class="section">
              <div class="row">
                <div class="col-md-12 left-align">
                  <h2 class="dark-text">
                    Analysis
                    <p>Syed Abbas</p>
                    <hr />
                  </h2>
                </div>
                <!-- end col -->
              </div>
              <!-- end row -->

              <div class="row">
                <div class="col-md-12">
                  <h4>Stakeholders</h4>
                  <p>
                    The primary stakeholders for this messaging service are
                    teenage students, mainly in school, who use the platform to
                    stay connected with friends both during and outside of
                    school hours. The app supports communication around
                    homework, class projects, and planning social activities
                    like get-togethers or study groups. These users value quick,
                    easy, and fun ways to chat—whether one-on-one or in group
                    chats—with options to personalize their profiles and manage
                    privacy.
                  </p>

                  <h4>User Stories</h4>

                  <strong>Persona: Eli, 14, casual gamer</strong>
                  <p>Story:</p>
                  <p>
                    As a student who just wants a quick and easy way to talk to
                    friends, I want to be able to send and receive messages
                    instantly, So that I can have casual conversations or make
                    quick plans without delays or complex features.
                  </p>
                  <p>Acceptance Criteria:</p>

                  <ul>
                    <li>
                      Given I'm logged into the app, When I open a chat and type
                      a message, Then the message is sent and received by the
                      other user in real time.
                    </li>

                    <li>
                      Given I receive a message from a friend, When it arrives,
                      Then I see it instantly in the chat view without needing
                      to refresh.
                    </li>

                    <li>
                      Given I have a stable internet connection, When I send a
                      message, Then there is no significant delay or failure in
                      delivery.
                    </li>
                  </ul>

                  <strong
                    >Persona: Marcus, 16, school club organizer and student
                    leader</strong
                  >
                  <p>Story:</p>
                  <p>
                    As a student who manages different school club activities
                    and group projects, I want to be able to create group chats,
                    name them, and add or remove members, So that I can keep
                    discussions organized and ensure only the relevant people
                    are part of each conversation.
                  </p>
                  <p>Acceptance Criteria:</p>

                  <ul>
                    <li>
                      Given I am a registered user, When I create a new chat and
                      select "group", Then I can set a group name and choose
                      members to add.
                    </li>

                    <li>
                      Given I am the group creator or admin, When I open group
                      settings, Then I can add or remove members at any time.
                    </li>

                    <li>
                      Given I open a group chat, When I view the group details,
                      Then I can see a full list of current participants.
                    </li>
                  </ul>

                  <strong
                    >Persona: Zara, 15, creative and social student new to the
                    platform</strong
                  >
                  <p>Story:</p>
                  <p>
                    As a new user who likes expressing her personality online, I
                    want to customize my profile with a name, photo, and status,
                    and also manage my login details, So that I can make my
                    account feel personal and stay in control of my privacy and
                    security.
                  </p>
                  <p>Acceptance Criteria:</p>

                  <ul>
                    <li>
                      Given I am logged into my account, When I open the profile
                      settings page, Then I can upload a profile photo, enter a
                      display name
                    </li>

                    <li>
                      Given I go to the security settings, When I update my
                      password, Then I am prompted to confirm the change and see
                      a success message.
                    </li>
                  </ul>

                  <h4>Design</h4>
                  <p>
                    To come up with a basic design, we deiced to discuss the
                    requirements and then explore how we can apply an
                    architecture
                  </p>

                  <strong>Architecture Style</strong>

                  <strong>Mircroservices Achitecure</strong>
                  <p>
                    The system is designed using microservices, allowing the
                    frontend and backend to be developed, deployed, and scaled
                    independently. Each service is responsible for a specific
                    function, improving flexibility and scalability.
                  </p>

                  <strong>Frontend Mircoservice (MVC)</strong>
                  <p>
                    Model: Represents the user interface data—like messages,
                    chat history, user profiles, and settings. The model
                    contains the necessary information for display but doesn't
                    directly handle user actions.
                  </p>
                  <p>
                    View: The UI components that the user interacts with,chat
                    rooms, buttons, and settings. This layer is responsible for
                    rendering data to the user in a way that's easy to
                    understand.
                  </p>
                  <p>
                    Controller: The logic layer that processes user inputs, such
                    as sending messages, joining group chats, or updating
                    profiles. It communicates with the backend to fetch data or
                    send requests and updates the view accordingly.
                  </p>

                  <strong>Backend Mircoservice (Model & Controller)</strong>
                  <p>
                    Model: Contains the business logic and data structure, such
                    as user group chat management. It also manages interactions
                    with the database.
                  </p>
                  <p>
                    Controller: The API controllers that handle incoming
                    requests from the frontend, such as creating accounts,
                    sending messages, or updating group chats. The controller
                    processes requests, interacts with the model (business
                    logic), and returns the necessary data to the frontend.
                  </p>
                  <strong> Design patterns </strong>
                  <p>
                    One of the main design patterns we have implemented is the
                    facade design pattern. This design pattern was key because
                    of the collaborative nature of the project, as abstracting
                    some of the behind-the-scenes logic would make it easier for
                    others to work on existing code.
                  </p>
                  <p>
                    We also implemented singletons within the database
                    management infrastructure
                  </p>

                  <strong>Database</strong>
                  <p>
                    Centralised storage for data. The database stores the
                    following:
                  </p>
                  <ul>
                    <li>User accounts (authentication details)</li>
                    <li>Messages</li>
                    <li>Chats</li>
                  </ul>
                </div>
                <!-- end col -->
              </div>
              <!-- end row -->
            </section>
            <!-- end section -->

            <section id="line4" class="section">
              <div class="row">
                <div class="col-md-12 left-align">
                  <h2 class="dark-text">
                    UI Development
                    <p>Syed Abbas</p>
                    <hr />
                  </h2>
                </div>
                <!-- end col -->
              </div>

              <div class="col-md-12">
                <h2 id="line4_1" class="font">Initial Components</h2>
                <p>
                  As dicussed previously, for the user interface we as a group
                  have decided to use React Js with NextJs and Typescript. For
                  styling, we have decided to use TailwindCSS. I have taken the
                  role to be the main frontend developer in the group. To start
                  off, I looked at the designs ad user intefaces for other
                  messaging service applications such as Mircrosoft Teams. With
                  this, I was able to decide on the main components that I would
                  need to create for a foundational structure that can be built
                  on.
                </p>

                <h4 id="line4_2">Components for Basic Structure</h4>
                <p>
                  As we are following MVC, these are our main view components
                </p>

                <div class="row d-flex align-items-stretch text-center">
                  <!-- Sidebar -->
                  <div class="col-md-4 mb-4 d-flex">
                    <div class="card w-100 h-100">
                      <img
                        src="images/upload/sidebar.png"
                        class="card-img-top img-fluid"
                        alt="Sidebar"
                        style="height: 200px; object-fit: cover"
                      />
                      <div class="card-body d-flex flex-column">
                        <h3 class="card-title">Sidebar</h3>
                        <p class="card-text">
                          Having this as part of the basic structure is crucial,
                          as it will be the component that allows the users to
                          interact with the application and access different
                          pages such as settings or group chats. Therefore,
                          features will be built on top of this. After
                          discussing with the team, we have decided to only have
                          3 menus. Direct will allow users to access any priavte
                          chats they may have. Group chats will allow users to
                          access any other chats they may have with multiple
                          people. The settings menu will allow users to access
                          profile and notifications settings.
                        </p>
                      </div>
                    </div>
                  </div>

                  <!-- Chat List -->
                  <div class="col-md-4 mb-4 d-flex">
                    <div class="card w-100 h-100">
                      <img
                        src="images/upload/chatlist.png"
                        class="card-img-top img-fluid"
                        alt="Chat List"
                        style="height: 200px; object-fit: cover"
                      />
                      <div class="card-body d-flex flex-column">
                        <h3 class="card-title">Chat List</h3>
                        <p class="card-text">
                          This component will allow users to access and their
                          chats. This is another main components as further
                          functionality will be built on top, such as accesssing
                          specific chat messages and loading chats from API's.
                          Using the search bar at the top users will be able to
                          search for specific chats and filter the list
                          accordingly. To start off, I have decided to use mock
                          data to ensure and test that the chats are displayed
                          appropriatelty. Later, I will be using GET requests to
                          fetch chats from the backend.
                        </p>
                      </div>
                    </div>
                  </div>

                  <!-- Chat Window -->
                  <div class="col-md-4 mb-4 d-flex">
                    <div class="card w-100 h-100">
                      <img
                        src="images/upload/chatwindow.png"
                        class="card-img-top img-fluid"
                        alt="Chat Window"
                        style="height: 200px; object-fit: cover"
                      />
                      <div class="card-body d-flex flex-column">
                        <h3 class="card-title">Chat Window</h3>
                        <p class="card-text">
                          This component will allow users to access their chat
                          messages and edit their chat to add and remove people,
                          hence being another main component, as features will
                          be implmeneted later on. As a start, I am using mock
                          data for the chat messages to test and ensure they are
                          displayed properly. This makes it easier for me to
                          apply the css styling.
                        </p>
                      </div>
                    </div>
                  </div>
                </div>

                <a href="images/upload/mainmenu.png" data-rel="prettyPhoto"
                  ><img
                    src="images/upload/mainmenu.png"
                    alt=""
                    class="img-responsive img-thumbnail"
                    style="
                      width: 75%;
                      max-width: 500px;
                      margin: 1rem auto;
                      display: block;
                    "
                  />
                </a>

                <h4 id="line4_3">Chat Modal Implementation</h4>
                <p>
                  For users to be able to create chats and update them, I
                  decided to create a modal which can update.
                </p>
                <p>In the modal, users can:</p>
                <ul>
                  <li>• Add participants to group chats</li>
                  <li>• Name the chat</li>
                  <li>• Remove participants</li>
                </ul>
                <a
                  href="images/upload/updatechatmodal.png"
                  data-rel="prettyPhoto"
                  ><img
                    src="images/upload/updatechatmodal.png"
                    alt=""
                    class="img-responsive img-thumbnail"
                    style="
                      width: 85%;
                      max-width: 600px;
                      margin: 1rem auto;
                      display: block;
                    "
                  />
                </a>
                <p>
                  The same modal component is used to create and update chats.
                  In the chat list, there is a 'New Chat' button and in the chat
                  window component there is an 'Edit' button to add or remove
                  participants
                </p>
                <a
                  href="images/upload/updatechatmodal2.png"
                  data-rel="prettyPhoto"
                  ><img
                    src="images/upload/updatechatmodal2.png"
                    alt=""
                    class="img-responsive img-thumbnail"
                    style="
                      width: 75%;
                      max-width: 500px;
                      margin: 1rem auto;
                      display: block;
                    "
                  />
                </a>

                <h2 id="line4_2">Integrating with Backend</h2>
                <p>
                  As our main components have been developed, we now moved onto
                  creating model components to define requests and responses
                  that will be sent to the backend API endpoints.
                </p>
                <p>Here is an exmple of create chat request:</p>
                <pre class="brush: js">
                  export interface CreateChatRequest {
                    initiator: string;
                    chat_name: string;
                    participants: string | string[];
                    is_group: boolean;
                  }
                  </pre
                >
                <p>
                  I have also defined controller components that will be sending
                  the actual requests to to the backend endpoins. 
                </p>

                <pre class="brush: js">
                  export const createChatRequest = (
                    request: CreateChatRequest,
                    token: string
                  ): Promise<CreateChatResponse> => {
                    return fetch(`${whisperCore}/create-chat`, {
                      method: "POST",
                      headers: {
                        "Content-Type": "application/json",
                        Authorization: `Bearer ${token}`,
                      },
                      body: JSON.stringify(request),
                    })
                      .then((response) =>
                        response
                          .json()
                          .then((data) => ({ data, ok: response.ok, status: response.status }))
                      )
                      .then(({ data, ok, status }) => {
                        if (!ok) {
                          if (status === 409) {
                            throw new Error("Chat name already exists");
                          }
                          throw new Error(data.detail || `Failed to create chat: ${status}`);
                        }
                        return data;
                      })
                      .catch((error) => {
                        console.error("Create chat error:", error);
                        throw error;
                      });
};
                  </pre
                >

                <p>
                  We also created a handler function which can be called by the view components and this further isolated the layers and therefore prevents tight coupling.
                </p>

                <pre class="brush: js">
                  export const createGroupChatHandler = async (
                    chatName: string,
                    participants: string[]
                  ): Promise<string | null> => {
                    try {
                      const token = Cookies.get("token");
                      const username = Cookies.get("username");
                  
                      if (!token || !username) {
                        return redirectToLogin("You need to be logged in to create a group chat");
                      }
                  
                      if (!chatName || chatName.trim() === "") {
                        errorHandler("Group chat name is required", "error");
                        return null;
                      }
                  
                      if (!participants || participants.length === 0) {
                        errorHandler(
                          "You must add at least one participant to the group",
                          "error"
                        );
                        return null;
                      }
                  
                      const chatData = await createChatRequest(
                        {
                          initiator: username,
                          chat_name: chatName,
                          participants: participants,
                          is_group: true,
                        },
                        token
                      );
                  
                      return chatData.chat_id;
                    } catch (error: unknown) {
                      return handleAsyncError(error, "An unexpected error occurred while creating the group chat.", null);
                    }
                  };
                }
               </pre
                >

                <p>
                  In the view components, such as the chat modal component, we
                  can simply call the function from chat controller to trigger
                  the API call. Here we pass in the data when sending requests:
                </p>

                <pre class="brush: js">
                    const handleCreateDirectChat = async (userName: string): Promise<void> => {
                    const existingChat: Chat | undefined = chats.find(
                      (chat) => chat.name === userName && !chat.isGroup
                    );
                
                    if (existingChat) {
                      selectChat(existingChat.id);
                      moveToTop(existingChat.id);
                    } else {
                      const responseChatId = await createDirectChatHandler(userName);
                      if (!responseChatId) {
                        errorHandler("Failed to create chat");
                        return;
                      }
                
                      const newChat: Chat = {
                        id: responseChatId,
                        name: userName,
                        lastMessage: "Start a conversation...",
                        time: "Now",
                        unread: 0,
                        isGroup: false,
                        initiator: username || "",
                      };
                
                      setChats((prev) => [newChat, ...prev]);
                      selectChat(newChat.id);
                      setMessages((prev) => ({
                        ...prev,
                        [newChat.id]: [],
                      }));
                    }
                  };
                  </pre
                >

                <h2 id="line4_3">Login System</h2>
                <p>To build the login system, we first setup a user interface by building components. So we first setup a login and register page. The backend endpoints for login and register 
                 were being built in parallel, which allowed us to clearly communicate our ideas and issues during development.</p>
                 
 
                 <p>For Registering: </p>
                 <a href="images/upload/registering.png" data-rel="prettyPhoto"
                   ><img
                     src="images/upload/registering.png"
                     alt=""
                     class="img-responsive img-thumbnail"
                     style="
                       width: 75%;
                       max-width: 500px;
                       margin: 1rem auto;
                       display: block;
                     "
                 /></a>
 
                 <p>For registering, we have added a restriction on the password to be a minimum of 8 characters long. This means they are more secure, as they would statistcially be harder to guess.</p>
 
 
                 <p>For Logging in: </p>
                 <a href="images/upload/login.png" data-rel="prettyPhoto"
                   ><img
                     src="images/upload/login.png"
                     alt=""
                     class="img-responsive img-thumbnail"
                     style="
                       width: 75%;
                       max-width: 500px;
                       margin: 1rem auto;
                       display: block;
                     "
                 /></a>
 
                 <p>Once users login, they will be taken to the main menu, ready to send messages. The token is cached, so if the user refreshes the page, they will not be asked to log back in.</p>

                <h2 id="line4_4">Frontend UI Refresh</h2>

                <p>As part of agile development and updates, as a team, we decided to design a new user interface that is more intuitive and user friendly. This involved brainstorming sessions and design reviews.</p>

                <h3>What we didn't change</h3>
                <p>We chose to retain several core components and their placements, such as the sidebar and chat window. These elements are standard in messaging services and align with user expectations. 
                  Additionally, we kept other familiar features like search bars to ensure a seamless and intuitive experience for our users.</p>

                <h3>What we changed</h3>

                <p>The most significant change we made was updating the colour palette. After gathering feedback, we realised that our stakeholders preferred a clean black-and-white scheme. This not only makes menus and buttons easier to distinguish but also gives the app a more mature aesthetic-something our secondary school users value over the previous blue colour scheme.
                  Additionally, we reorganised the settings page, moving it from the sidebar to a separate menu accessible via a dedicated button. This change declutters the home menu, allowing users to focus on their chats and access settings only when needed. 
                  We also refreshed the UI design for dialogs and modals. The edit chat, leave chat, and delete chat dialogs are now more visually appealing and user-friendly, enhancing the overall experience. </p>

                <h3>Login/Signup Refresh</h3>

                <a href="images/upload/loginRefresh.png" data-rel="prettyPhoto"
                   ><img
                     src="images/upload/loginRefresh.png"
                     alt=""
                     class="img-responsive img-thumbnail"
                     style="
                       width: 75%;
                       max-width: 500px;
                       margin: 1rem auto;
                       display: block;
                     "
                 /></a>

                <h3>Main Menu Refresh</h3>

                <a href="images/upload/MainMenuRefresh.png" data-rel="prettyPhoto"
                   ><img
                     src="images/upload/MainMenuRefresh.png"
                     alt=""
                     class="img-responsive img-thumbnail"
                     style="
                       width: 75%;
                       max-width: 500px;
                       margin: 1rem auto;
                       display: block;
                     "
                 /></a>

                <h3>Setting Menu Refresh</h3>

                <a href="images/upload/SettingMenuRefresh.png" data-rel="prettyPhoto"
                   ><img
                     src="images/upload/SettingMenuRefresh.png"
                     alt=""
                     class="img-responsive img-thumbnail"
                     style="
                       width: 75%;
                       max-width: 500px;
                       margin: 1rem auto;
                       display: block;
                     "
                 /></a>

                <h3>Edit Chat Dialog/Modal Refresh</h3>

                <a href="images/upload/EditChatRefresh.png" data-rel="prettyPhoto"
                   ><img
                     src="images/upload/EditChatRefresh.png"
                     alt=""
                     class="img-responsive img-thumbnail"
                     style="
                       width: 75%;
                       max-width: 500px;
                       margin: 1rem auto;
                       display: block;
                     "
                 /></a>

                
              </div>

              <!-- end row -->
            </section>
            <!-- end section -->

            <section class="section">
              <div class="row">
                <div class="col-md-12 left-align">
                  <h2 id="line6" class="dark-text">
                    Database
                    <p>Jamie Wells</p>
                    <hr />
                  </h2>
                </div>
                <!-- end col -->
              </div>
              <h4 id="line6_1">Setup</h4>
              <p>
                After deciding that we'd use MongoDB for our database
                operations, we got started by exploring the UI and some of the
                documentation that Mongo has laid out. Initially, we set up two
                databases—one for development, and one for production.
              </p>
              <a href="images/upload/mongo.png" data-rel="prettyPhoto"
                ><img
                  src="images/upload/mongo.png"
                  alt=""
                  class="img-responsive img-thumbnail"
              /></a>
              <p>
                At first, we had difficulty connecting with this online
                instance. We had successfully established a connection, were
                able to create tables and insert entries into these tables, but
                we realised that this was only on a local instance. We quickly
                changed our connection string to reflect that of the online
                instance, by using the command:
              </p>
              <pre class="brush: bash">
mongosh "mongodb+srv://{username}:{password}@whispercluster.e03b9.mongodb.net/dev?retryWrites=true&w=majority&appName=WhisperCluster"
              </pre>
              <p>
                This command would connect us to the online instance and allow
                us to propogate our requests externally.
              </p>
              <h4 id="line6_2">UserManager</h4>
              <p>
                The MongoUserManager class is where the PyMongo helper methods
                are defined. When the server starts up, only one instance of
                MongoUserManager will be created (when the app settings are
                defined), which is much more memory efficient than creating a
                new object for each incoming request.
              </p>
              <p>
                These requests are then handled by the endpoints defined, and
                use the helper functions to receive outputs on the request data,
                where the request data is parsed in as arguments.
              </p>
              <p>
                Below is an example of how our register user endpoint uses the
                register user method in MongoUserManager to execute the
                necessary database operations:
              </p>
              <pre class="brush: python">
@app.post("/register")
async def register(request: models.RegisterRequest):
    try:
        # Validate input
        if not request.username or not request.password:
            raise HTTPException(
                status_code=400, detail="Username and password are required"
            )

        # attempting to register user
        response = config.user_manager.register_user(request.username, request.password)
        if response:
            config.logger.info("User registered successfully")
            return {"message": "User registered successfully"}
        (...)
              </pre>
              <p>
                This method will get the user details from the request and use
                the register_user method in the MongoUserManager class to
                execute the database logic and return the result. This
                particular method returns a boolean, indicating whether the user
                registration was successful or not:
              </p>
              <pre class="brush: python">
def register_user(self, username: str, password: str) -> bool:
    user_exists = self.users_collection.find_one({"username": username})

    if user_exists:
        return False

    hashed_password = bcrypt.hashpw(password.encode("utf-8"), bcrypt.gensalt())

    user_document = {
        "username": username,
        "password": hashed_password,
        "created_at": time.time(),
    }
    self.users_collection.insert_one(user_document)
    self.config.logger.info("\nUser added to DB")
    return True
              </pre>
              <br />
              <h4 id="line6_3">Endpoints</h4>
              <p>
                The pymongo API logic had now been written, and the next step
                was writing request handlers that would operate on this logic.
                Here is an example of one of the endpoints we have for logging
                in:
              </p>
              <pre class="brush: python">
@app.post("/login")
async def login(request: models.LoginRequest):
    """User login endpoint."""
    try:
        # Validate credentials
        if config.user_manager.validate_user(request.username, request.password):
            # Generate and return login token
            token = config.user_manager.generate_token(request.username)
            return {"token": token, "username": request.username}
        else:
            raise HTTPException(status_code=401, detail="Invalid credentials")
    except Exception as e:
        config.logger.error(f"Login error: {e}")
        raise HTTPException(status_code=500, detail="Login failed")
              </pre>
              <p>
                This endpoint will take the LoginRequest pydantic model that
                we've defined as a parameter, use the helper functions defined
                in the UserManager class to validate that the user's credentials
                can be registered, generate a web token associated with the user
                and return it in the response.
              </p>
              <p>
                It's worth noting that we have also written comprehensive
                documentation on each endpoint, including how to call it, what
                it's expecting in the request body, and what it returns. This
                documentation takes the form of a README.md file in our backend
                repository.
              </p>
              <a href="images/upload/endpoints.png" data-rel="prettyPhoto"
                ><img
                  src="images/upload/endpoints.png"
                  alt=""
                  class="img-responsive img-thumbnail"
              /></a>
              <br />
              <br />
            </section>
            <!-- end section -->

            <section id="line7" class="section">
              <div class="row">
                <div class="col-md-12 left-align">
                  <h2 class="dark-text">
                    Full-Stack Integration
                    <p>Mahbubur Rahman</p>
                    <hr />
                  </h2>
                </div>
                <!-- end col -->
              </div>
              <!-- end row -->

              <div class="row">
                <div class="col-md-12">
                  <h4 id="line7_1">Microservices Architecture Integration</h4>
                  <p>
                    Our chat application is built on a microservices
                    architecture with two main services: whisper-client
                    (frontend) and whisper-core (backend). The whisper-client
                    handles all user interface components and WebSocket
                    connections, while whisper-core manages data persistence and
                    REST API endpoints.
                  </p>

                  <h4>System Architecture</h4>
                  <a href="images/upload/fullstack1.png" data-rel="prettyPhoto">
                    <img
                      src="images/upload/fullstack1.png"
                      alt="Microservices Architecture Diagram"
                      class="img-responsive img-thumbnail"
                    />
                  </a>

                  <h4>REST API Integration with whisper-core</h4>
                  <p>
                    The frontend (whisper-client) communicates with whisper-core
                    via REST API endpoints for operations that require data
                    persistence, such as user authentication, creating chats,
                    and storing messages.
                  </p>

                  <pre class="brush: js">
            // lib/model/chatModel.ts - Sending a message via REST API
            public async sendMessage(chatId, sender, message) {
              const requestBody = {
                chat_id: chatId,
                sender: sender,
                message: message,
              };
            
              const response = await fetch(
                `${process.env.NEXT_PUBLIC_API_URL}send-message`,
                {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify(requestBody),
                }
              );
            
              return await response.json();
            }</pre
                  >

                  <h4>whisper-core Backend API Handler</h4>
                  <p>
                    Our FastAPI backend in whisper-core processes these requests
                    and persists data to MongoDB.
                  </p>

                  <pre class="brush: python">
            # In whisper-core service
            @app.post("/send-message")
            async def send_message(request: models.SendMessageRequest):
                """Endpoint to add a message to a chat."""
                try:
                    message_document = config.user_manager.add_message_to_chat(
                        chat_id=request.chat_id, 
                        sender=request.sender, 
                        message=request.message
                    )
                    
                    return message_document
                except Exception as e:
                    raise HTTPException(
                        status_code=500, 
                        detail={"message": "Failed to send message"}
                    )</pre
                  >

                  <h4>WebSocket Implementation in whisper-client</h4>
                  <p>
                    Unlike traditional architectures, our WebSocket
                    implementation resides in the whisper-client microservice
                    rather than the backend. This design choice allows for more
                    responsive real-time updates and reduces load on the core
                    backend services.
                  </p>

                  <a href="images/upload/fullstack2.png" data-rel="prettyPhoto">
                    <img
                      src="images/upload/fullstack2.png"
                      alt="WebSocket in Client Architecture"
                      class="img-responsive img-thumbnail"
                    />
                  </a>
                  <div style="margin: 1rem 0">
                    <p>
                      The WebSocket server is implemented in the whisper-client
                      service, allowing it to handle real-time message delivery
                      directly. This architecture enables the client to manage
                      WebSocket connections and broadcast messages to
                      participants in a chat.
                    </p>
                  </div>

                  <a href="images/upload/webby.png" data-rel="prettyPhoto">
                    <img
                      src="images/upload/webby.png"
                      alt="WebSocket in Client Architecture"
                      class="img-responsive img-thumbnail"
                    />
                  </a>

                  <h4>WebSocket Server in whisper-client</h4>
                  <pre class="brush: js">
            // In whisper-client service - WebSocket server implementation
            const WebSocket = require('ws');
            const http = require('http');
            const server = http.createServer(app);
            const wss = new WebSocket.Server({ server });
            
            // Store active connections
            const connections = new Map();
            
            wss.on('connection', (ws, req) => {
              const token = getTokenFromRequest(req);
              const username = validateToken(token);
              
              if (!username) {
                ws.close(1008, 'Invalid token');
                return;
              }
              
              // Store connection by username
              connections.set(username, ws);
              
              ws.on('message', (messageData) => {
                const data = JSON.parse(messageData);
                
                if (data.type === 'send_message') {
                  // Process message and broadcast to participants
                  const { chat_id, sender, message } = data;
                  
                  // Get chat participants from local cache or API
                  getChatParticipants(chat_id).then(participants => {
                    // Broadcast to all participants
                    participants.forEach(participant => {
                      const participantWs = connections.get(participant);
                      if (participantWs && participantWs.readyState === WebSocket.OPEN) {
                        participantWs.send(JSON.stringify({
                          type: 'new_message',
                          chat_id,
                          sender,
                          message
                        }));
                      }
                    });
                  });
                }
              });
              
              ws.on('close', () => {
                // Remove connection on disconnect
                connections.delete(username);
              });
            });</pre
                  >

                  <h4>WebSocket Client Implementation</h4>
                  <p>
                    The React frontend connects to the WebSocket server to
                    receive real-time updates:
                  </p>

                  <pre class="brush: js">
            // In React component - WebSocket client connection
            const [socket, setSocket] = useState(null);
            
            useEffect(() => {
              const token = localStorage.getItem('token');
              if (!token) return;
              
              // Connect to WebSocket server
              const ws = new WebSocket(`${process.env.NEXT_PUBLIC_WS_URL}?token=${token}`);
              
              ws.onopen = () => {
                console.log('WebSocket connection established');
              };
              
              ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                
                if (data.type === 'new_message') {
                  // Update chat with new message
                  if (data.chat_id === selectedChat) {
                    setMessages(prev => [...prev, {
                      sender: data.sender,
                      text: data.message,
                      timestamp: Date.now() / 1000
                    }]);
                  } else {
                    // Update chat list to show new message indicator
                    setUnreadChats(prev => new Set([...prev, data.chat_id]));
                  }
                }
              };
              
              ws.onclose = () => {
                console.log('WebSocket connection closed');
              };
              
              setSocket(ws);
              
              // Clean up on unmount
              return () => {
                if (ws) ws.close();
              };
            }, []);</pre
                  >

                  <h4>Optimistic UI Updates</h4>
                  <p>
                    To enhance user experience, we implement optimistic UI
                    updates that show messages immediately when sent:
                  </p>

                  <pre class="brush: js">
            // Adding a message optimistically
            const handleSendMessage = async () => {
              if (!newMessage.trim() || !selectedChat || !username) return;
            
              // Generate client ID for tracking
              const clientId = generateClientId();
              
              // Create pending message and add it immediately
              const pendingMessage = {
                sender: username,
                text: newMessage,
                timestamp: Date.now() / 1000,
                clientId: clientId,
                isPending: true
              };
            
              // Add to UI immediately
              setMessages(messages => [...messages, pendingMessage]);
              setNewMessage("");
              
              // 1. Send to REST API for persistence
              try {
                const response = await sendMessage(
                  selectedChat, 
                  username, 
                  pendingMessage.text
                );
                
                // 2. Send to WebSocket for real-time delivery
                if (socket && socket.readyState === WebSocket.OPEN) {
                  socket.send(JSON.stringify({
                    type: 'send_message',
                    chat_id: selectedChat,
                    sender: username,
                    message: pendingMessage.text
                  }));
                }
                
                // Update message status once confirmed
                setMessages(messages => 
                  messages.map(msg => 
                    msg.clientId === clientId 
                      ? { ...msg, isPending: false, _id: response._id } 
                      : msg
                  )
                );
              } catch (error) {
                // Handle error state
                setMessages(messages => 
                  messages.map(msg => 
                    msg.clientId === clientId 
                      ? { ...msg, text: `${msg.text} (Failed)`, isPending: false } 
                      : msg
                  )
                );
              }
            };</pre
                  >

                  <h4>Benefits of Client-side WebSocket Architecture</h4>
                  <p>
                    By implementing WebSockets in the whisper-client service
                    rather than whisper-core, we gain several advantages:
                  </p>
                  <ul>
                    <li>Reduced load on the core backend service</li>
                    <li>Lower latency for real-time message delivery</li>
                    <li>
                      Simplified scaling for the WebSocket service independently
                    </li>
                    <li>
                      Clearer separation of concerns between persistence (REST
                      API) and real-time communication
                    </li>
                  </ul>

                  <div class="intro2 clearfix">
                    <p>
                      <i class="fa fa-exclamation-triangle"></i> Even with
                      WebSockets implemented in the client service, we maintain
                      security by requiring token authentication for all
                      connections. The microservices architecture allows each
                      component to be scaled independently based on its specific
                      resource needs.
                    </p>
                  </div>
                </div>
                <div>
                  <h4 id="line7_2">Update: Migration to Modular Architecture with whisper-ws</h4>
                      <p>
                        As part of our commitment to scalability, performance, and long-term maintainability, we have migrated to a more modular architecture by introducing a dedicated WebSocket service, <code>whisper-ws</code>. Previously, our WebSocket server was bundled within the <code>whisper-client</code>, which allowed us to ship real-time features quickly in the early stages. However, as our user base grew and feature demands increased, this architecture began to show its limits.
                      </p>

                      <p>
                        We realised that handling WebSocket connections inside the client service was creating unnecessary coupling, making it harder to scale, debug, and maintain. Additionally, we wanted a solution that could handle high traffic loads, support horizontal scaling, and enable specialised teams to improve real-time features without affecting the frontend or backend.
                      </p>

                      <p>
                        To address these challenges, we introduced <code>whisper-ws</code> as a standalone microservice. This service is now responsible for managing all WebSocket connections, broadcasting real-time messages, and performing lightweight authentication by verifying users against <code>whisper-core</code> before allowing messages to pass through.
                      </p>

                      <h4>Updated System Architecture</h4>
                      <pre class="mermaid">
                      graph TD
                        subgraph Frontend
                          A[whisper-client]
                        end

                        subgraph Backend
                          B[whisper-core]
                        end

                        subgraph WebSocket Service
                          C[whisper-ws]
                        end

                        A -->|REST API| B
                        A -->|WebSocket| C
                        C -->|Auth check| B
                        B -->|Auth response| C
                        C -->|Real-time messages| A
                      </pre>

                      <h4>Why We Made This Change</h4>
                      <ul>
                        <li><strong>Scalability Needs:</strong> As usage grew, we needed the ability to scale the WebSocket layer independently to handle thousands of concurrent connections without overloading the backend.</li>
                        <li><strong>Performance Improvements:</strong> Offloading real-time message handling from whisper-client reduced latency, improved message delivery speed, and freed up resources on the client tier.</li>
                        <li><strong>Separation of Concerns:</strong> By decoupling WebSocket responsibilities, each service could specialise — whisper-core focuses on persistence and business logic, whisper-client on UI, and whisper-ws on real-time communication.</li>
                        <li><strong>Maintainability:</strong> Isolated services simplify troubleshooting, code upgrades, and performance optimisations, reducing the risk of system-wide regressions.</li>
                        <li><strong>Security & Reliability:</strong> whisper-ws authenticates every WebSocket connection through whisper-core, ensuring only authorised users can send or receive messages, improving overall system trustworthiness.</li>
                        <li><strong>Future Flexibility:</strong> This architecture prepares us to introduce advanced real-time features (e.g., typing indicators, presence tracking, delivery receipts) without burdening the backend or frontend teams.</li>
                      </ul>

                      <h4>Benefits of the New Architecture</h4>
                      <ul>
                        <li><strong>Horizontal Scaling:</strong> whisper-ws can be horizontally scaled to handle growing traffic without impacting the backend or frontend.</li>
                        <li><strong>Improved Resilience:</strong> Failures in the WebSocket layer are now isolated and do not affect core backend operations or user interfaces.</li>
                        <li><strong>Faster Development Cycles:</strong> Dedicated teams can work on whisper-ws, whisper-core, and whisper-client in parallel, speeding up delivery of features and improvements.</li>
                        <li><strong>Better Monitoring & Observability:</strong> Logs, metrics, and performance can be tracked per service, allowing more precise detection and resolution of issues.</li>
                      </ul>

                      <p>
                        Overall, this migration positions our system to support rapid growth, deliver a superior user experience, and evolve with the demands of modern real-time applications.
                      </p>

                </div>
              </div>
              <section id="line12" class="section">
                <div class="row">
                  <div class="col-md-12 left-align">
                    <h2 class="dark-text">
                      Authentication
                      <p>Mahbubur Rahman</p>
                      <hr />
                    </h2>
                    
                  </div>
                  
                  <!-- end col -->
                </div>
                <!-- end row -->

                

                <section>
                  <div class="row">
                    <div class="col-md-12">
                      <h4>JWT Authentication Implementation</h4>
                      <p>
                        Whisper uses JSON Web Tokens (JWT) for secure authentication between the frontend and backend services.
                        This stateless authentication method allows us to maintain secure sessions without storing session data on the
                        server, which aligns with our microservices architecture and scalability goals.
                      </p>
                
                      <h4>How JWT Authentication Works in Whisper</h4>
                      <p>
                        When a user logs in or registers, our backend generates a signed JWT that contains encoded user information.
                        This token is then stored in the client's cookies and used for subsequent API requests to authenticate the user.
                      </p>
                
                      <div class="mermaid">
                        sequenceDiagram
                        participant User
                        participant Frontend
                        participant Backend
                        participant Database
                        User->>Frontend: Enter credentials
                        Frontend->>Backend: POST /login with username & password
                        Backend->>Database: Validate credentials
                        Database-->>Backend: Credentials valid
                        Backend->>Backend: Generate JWT with payload & secret key
                        Backend-->>Frontend: Return JWT token
                        Frontend->>Frontend: Store JWT in cookies
                        Frontend-->>User: Redirect to dashboard
                        Note over User,Database: Subsequent Authenticated Requests
                        User->>Frontend: Access protected resource
                        Frontend->>Backend: Request with JWT in header
                        Backend->>Backend: Verify JWT signature
                        Backend->>Backend: Decode & validate claims
                        Backend-->>Frontend: Return protected resource
                        Frontend-->>User: Display protected resource
                      </div>
                
                      <h4>JWT Token Structure</h4>
                      <p>Our JWT tokens consist of three parts:</p>
                      <ol>
                        <li><strong>Header</strong>: Contains the token type and signing algorithm</li>
                        <li><strong>Payload</strong>: Contains user data and metadata (expiration, issuer, etc.)</li>
                        <li><strong>Signature</strong>: Ensures the token hasn't been tampered with</li>
                      </ol>
                
                      <div class="mermaid">
                        graph TD
                        A[JWT Token] --> B[Header]
                        A --> C[Payload]
                        A --> D[Signature]
                        B --> B1[Algorithm: HS256]
                        B --> B2[Type: JWT]
                        C --> C1[User ID]
                        C --> C2[Username]
                        C --> C3[Expiration time]
                        C --> C4[Issued at]
                        D --> D1[Signed with SECRET_KEY]
                        D --> D2[Prevents tampering]
                      </div>
                
                      <h4>Frontend Authentication Implementation</h4>
                      <h5>Login Process</h5>
                      <p>
                        The frontend handles user authentication through API requests to the backend. When a user submits their
                        credentials, the frontend sends a request to the login endpoint, and upon successful authentication, stores the
                        JWT token in cookies for future requests.
                      </p>
                
                      <pre class="brush: js">
                // Login Request Implementation
                export const LoginRequest = (
                  username: string,
                  password: string
                ): Promise<LoginRegisterResponse> => {
                  return fetch(`${process.env.NEXT_PUBLIC_API_URL}login`, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ username, password }),
                  })
                    .then(async (res) => {
                      const data = await res.json();
                      if (res.ok) {
                        // Store the JWT token in cookies with secure settings
                        Cookies.set("token", data.token, {
                          sameSite: "Strict",
                          secure: true,
                          expires: 1, // 1 day expiration
                        });
                        localStorage.setItem("username", username);
                        return { status: "SUCCESS", msg: null } as const;
                      } else {
                        return {
                          status: "FAILURE",
                          msg: data.detail || "Unknown error",
                        } as const;
                      }
                    })
                    .catch((err) => {
                      return { status: "FAILURE", msg: err as string } as const;
                    });
                };
                
                // Function to add JWT token to API requests
                export const authenticatedFetch = (
                  url: string,
                  options: RequestInit = {}
                ): Promise<Response> => {
                  const token = Cookies.get("token");
                
                  if (!token) {
                    throw new Error("No authentication token found");
                  }
                
                  const headers = {
                    ...options.headers,
                    Authorization: `Bearer ${token}`,
                  };
                
                  return fetch(url, { ...options, headers });
                };
                      </pre>
                
                      <h5>Registration Process</h5>
                      <p>
                        Similarly, the registration process sends user credentials to the backend's register endpoint. Upon successful
                        registration, the user is redirected to the login page to authenticate with their new credentials.
                      </p>
                
                      <h4>Backend Authentication Implementation</h4>
                      <h5>JWT Token Generation</h5>
                      <p>
                        In the backend, when a user successfully authenticates, we generate a JWT token using a secure secret key and
                        set an appropriate expiration time.
                      </p>
                
                      <pre class="brush: python">
                # JWT Token Generation in whisper-core
                def generate_token(self, username: str) -> str:
                    """Generate a JWT token for authenticated users."""
                    expiration = datetime.datetime.utcnow() + datetime.timedelta(hours=24)
                
                    payload = {
                        "sub": username,
                        "exp": expiration,
                        "iat": datetime.datetime.utcnow(),
                        "iss": "whisper-core",
                    }
                
                    token = jwt.encode(payload, self.config.secret_key, algorithm="HS256")
                    return token
                      </pre>
                
                      <h5>Token Validation</h5>
                      <p>
                        For protected endpoints, we verify the token's authenticity by checking its signature and validating its
                        claims.
                      </p>
                
                      <pre class="brush: python">
                # JWT Token Validation Middleware in whisper-core
                async def verify_token(request: Request):
                    """Middleware to validate JWT tokens from incoming requests."""
                    token = request.headers.get("Authorization")
                    if not token:
                        raise HTTPException(status_code=401, detail="Token missing")
                
                    try:
                        if token.startswith("Bearer "):
                            token = token[7:]
                
                        payload = jwt.decode(
                            token,
                            config.secret_key,
                            algorithms=["HS256"],
                            options={"verify_signature": True, "verify_exp": True},
                        )
                
                        username = payload.get("sub")
                        if not username:
                            raise HTTPException(status_code=401, detail="Invalid token")
                
                        user = config.user_manager.get_user(username)
                        if not user:
                            raise HTTPException(status_code=401, detail="User not found")
                
                        return username
                
                    except jwt.ExpiredSignatureError:
                        raise HTTPException(status_code=401, detail="Token expired")
                    except jwt.InvalidTokenError:
                        raise HTTPException(status_code=401, detail="Invalid token")
                      </pre>
                
                      <h4>Microservices Authentication Architecture</h4>
                      <p>
                        Our microservice architecture implements JWT authentication across the whisper-client and whisper-core
                        services, creating a secure, stateless system that can scale horizontally.
                      </p>
                
                      
                
                      <h5>Authentication Flow Between Services</h5>
                      <ol>
                        <li>The user authenticates with whisper-client through the login endpoint</li>
                        <li>Whisper-client forwards credentials to whisper-core's authentication API</li>
                        <li>Whisper-core validates credentials and generates a JWT token</li>
                        <li>The token is stored securely in whisper-client and used for all subsequent API requests</li>
                        <li>Whisper-client includes the JWT in all requests to protected endpoints</li>
                        <li>Whisper-core validates the JWT signature and claims before processing the request</li>
                        <li>WebSocket connections are also authenticated using the same JWT token</li>
                      </ol>
                      <p>
                        This architecture ensures that each service has clear responsibilities while maintaining secure communication
                        through JWT.
                      </p>
                
                      <h4>Security Considerations</h4>
                      <p>Our JWT implementation includes several security measures:</p>
                      <ol>
                        <li><strong>Token Expiration</strong>: All tokens have a 24-hour expiration time</li>
                        <li><strong>Secure Cookie Storage</strong>: Tokens are stored with the <code>Secure</code> and <code>SameSite=Strict</code> flags</li>
                        <li><strong>Password Hashing</strong>: User passwords are hashed using bcrypt before storage</li>
                        <li><strong>Minimal Payload</strong>: We store only essential information in the JWT payload</li>
                      </ol>
                      <p>
                        By implementing JWT authentication, we've created a scalable, stateless authentication system that works well
                        with our microservices architecture while maintaining high security standards.
                      </p>
                    </div>
                    <!-- end col -->
                  </div>
                  <!-- end row -->
                </section>
                <!-- end section -->
                
              <!-- Add this to the head section of the HTML to load the Mermaid JS library -->
              <script src="https://cdnjs.cloudflare.com/ajax/libs/mermaid/9.1.7/mermaid.min.js"></script>
              <script>
                document.addEventListener("DOMContentLoaded", function () {
                  mermaid.initialize({
                    startOnLoad: true,
                    theme: "default",
                    securityLevel: "loose",
                    flowchart: {
                      useMaxWidth: true,
                      htmlLabels: true,
                      curve: "basis",
                    },
                  });
                });
              </script>
            </section>
            <!-- end section -->

            <section id="line8" class="section">
              <div class="row">
                <div class="col-md-12 left-align">
                  <h2 class="dark-text">
                    Writing Tests
                    <p>Samuel Gagatek</p>
                    <hr />
                  </h2>
                </div>
                <!-- end col -->
              </div>
              <h4 id="line8_1">Unit Tests</h4>
              <p>
                Our project includes a robust suite of unit tests designed to
                ensure core logic works as expected across both backend and
                frontend systems.
              </p>

              <img
                src="images/upload/python_unit_test.png"
                alt="Unit tests image"
                style="max-width: 800px; width: 100%; height: auto"
              />
              <p>
                For the backend, we created focused unit tests, using pytest,
                around the MongoUserManager class, which handles database
                interactions such as user creation, chat management, and message
                storage. These tests mock MongoDB responses to validate logic
                without needing a real database connection.
              </p>

              <h2 id="line8_2">Frontend Testing</h2>
              <p>
                   For testing these components, we as a group decided to use
                   Vitest. Vitest is fast and efficient, using Vite's build
                   system for quick test runs. It works well with modern tools
                   like TypeScript and JSX. With simple APIs and built-in
                   features like mocking, it makes testing easier and faster.
                 </p>
 
                 <h3>Purpose of Testing UI Components</h3>
                 <p>
                   Testing UI components is important because it ensures that the
                   user interface works as expected, providing a smooth and
                   bug-free experience for users. It helps catch issues early,
                   preventing them from affecting the overall functionality or
                   user satisfaction. Additionally, UI testing ensures that
                   changes or new features don’t unintentionally break existing
                   parts of the application, maintaining consistency and
                   reliability.
                 </p>
 
                 <h3>Component Testing</h3>
                 <p>
                   For testing our componets, we first drafted out all the
                   possible scenarios we could cover in the test cases, by
                   carefully examining each component. This helped make sure the
                   tests provided a good overall coverage and made our components
                   more robust
                 </p>
 
                 <p>Here are some of the test cases:</p>
                  <img
                  src="images/upload/client_unit_test.png"
                  alt="Unit tests image"
                  style="max-width: 800px; width: 100%; height: auto"
                 />
                 <a href="images/upload/testPassing.png" data-rel="prettyPhoto"
                   ><img
                     src="images/upload/testPassing.png"
                     alt=""
                     class="img-responsive img-thumbnail"
                     style="
                       width: 75%;
                       max-width: 500px;
                       margin: 1rem auto;
                       display: block;
                     "
                /></a>

              <h4 id="line8_3">Database Testing</h4>
              <p>
                Now that the database had been set up and the request handlers
                for communicating to the database had been committed, it was
                time to start sending test requests to these endpoints.
              </p>
              <p>
                In order to this, we had two options. We could run copy and
                paste the localhost URL into the browser and add the endpoint we
                wanted to hit onto the end, but this wouldn't work for any
                request that required a request body or request header. To solve
                this, we used Postman, where we could customise the request
                type, body, and headers.
              </p>
              <a href="images/upload/postman.png" data-rel="prettyPhoto"
                ><img
                  src="images/upload/postman.png"
                  alt=""
                  class="img-responsive img-thumbnail"
              /></a>
              <p>
                By being able to add custom headers to each request, this would
                allow us to authenticate necessary requests with a custom
                Whisper API key so that users couldn't make unauthenticated
                requets. For our automated end-to-end tests, please see
                <a href="#line8">Writing Tests</a>.
              </p>

              <h4 id="line8_3">Integration Tests</h4>
              <img
                src="images/upload/python_integration_test.png"
                alt="Integration tests image"
                style="max-width: 800px; width: 100%; height: auto"
              />
              <p>
                Our <strong>integration tests</strong> simulate real user
                interactions and validate the system as a whole. Written in
                Python using <strong>pytest</strong>, these tests interact with
                live API endpoints, ensuring that requests and responses
                interact correctly with the MongoDB database.
              </p>

              <p>
                Each integration test covers scenarios like chat creation, user
                login, message sending, and permission validation. These tests
                help verify integration between components and provide high
                confidence that the endpoints behave correctly in
                production-like environments.
              </p>

              <h4 id="line8_4">How to Run the Tests</h4>
              <p>
                To ensure the stability and reliability of our application,
                we've set up both unit and integration test suites. You can run
                them locally using the following commands:
              </p>

              <h5>Backend Unit Tests (Python)</h5>
              <pre><code>pytest tests/unit_tests</code></pre>

              <h5>Backend Integration Tests (Python)</h5>
              <pre><code>pytest tests/integration_tests</code></pre>

              <h5>Frontend Unit Tests (TypeScript)</h5>
              <pre><code>npx vitest</code></pre>

              <h5>Testing in VSCode</h5>
              <p>
                VSCode and potentially other IDEs allow you to seamlessly run
                all your tests. Use the 'Testing' button to run all the tests,
                like the example below.
              </p>
              <img
                src="images/upload/running_tests_in_python.png"
                alt="Run tests Image"
                style="max-width: 800px; width: 100%; height: auto"
              />
              <img
                src="images/upload/tests_successful.png"
                alt="Successful tests image"
                style="max-width: 800px; width: 100%; height: auto"
              />

              <p>
                Make sure you have all necessary dependencies installed and any
                required services (like MongoDB) running if applicable. Running
                the full suite regularly helps catch regressions early and
                ensures all features continue to work as expected.
              </p>
              <h4>Test Coverage</h4>
              <p>
                Test converage can be viewed via the coverage PyPI module. It
                shows how much code has been covered by each test, as well as
                the lines that your tests have not hit. We decided to include
                our logic in the test coverage as if there are tests that are
                failing, it can be easier to debug why they're failing if you
                understand which lines in the model aren't being run.
              </p>
              <a href="images/upload/coverage.png" data-rel="prettyPhoto"
                ><img
                  src="images/upload/coverage.png"
                  alt=""
                  class="img-responsive img-thumbnail"
              /></a>
            </section>
            <!-- end section -->

            <section id="line9" class="section">
              <div class="row">
                <div class="col-md-12 left-align">
                  <h2 class="dark-text">
                    Deployment
                    <p>Jamie Wells</p>
                    <hr />
                  </h2>
                </div>
                <!-- end col -->
              </div>
              <!-- end row -->

              <h4 id="line9_1">Dockerisation</h4>
              <p>
                We decided that we would deploy our application through building
                an image, and deploying containers using that image. We would
                use Docker for this, as it was relatively straightforward to use
                and would integrate with AWS easily.
              </p>
              <p>
                The first step was creating a Dockerfile that we could run with
                Docker to build an image of our application. We decided to use a
                lightweight Python base image so that build times would be
                minimised. As we didn't need the extra features, this would
                decrease our build time by about 80% from 50 seconds to ~10
                seconds whilst maintaining all the functionality that we needed.
              </p>
              <pre class="brush: bash">
FROM python:3.13-slim

WORKDIR /app
COPY . /app

RUN pip install --no-cache-dir -r requirements.txt

CMD ["uvicorn", "app:app", "--host", "0.0.0.0", "--port", "8000"]
              </pre>
              <p>
                The next task was to construct a .yml file that would build and
                deploy our containers. We created two services; one for our
                FastAPI application, and one for our Mongo instance. We set it
                up so that our FastAPI container would depend on the container
                hosting Mongo, so that if container two was down, container one
                would no longer try and operate as normal, as this would cause
                connection issues with the database.
              </p>
              <h4 id="line9_2">Pushing to ECR</h4>
              <p>
                After a commit, if you want your changes to be reflected in your
                production service, you must rebuild your Docker image and push
                it to AWS ECR. You can do both these things by running the
                following command:
              </p>
              <pre class="brush: bash">
docker buildx build \
--platform linux/amd64 \
-t 374544621977.dkr.ecr.eu-west-2.amazonaws.com/whisper/core:latest \
--push .
              </pre>
              This will tell Docker to rebuild your image with the latest
              changes - because we are using a lightweight Python base image,
              this only took a few seconds. After the image has rebuilt itself
              to reflect the latest changes, it will push this image to ECR,
              which means that AWS has now been successfully updated to use the
              newest version of your application.
              <h4 id="line9_3">Deploying to ECS</h4>
              <p>
                The final step in the deployment process is spinning up new
                containers that are using the image hosting the updated version
                of our application. This is a simple case of taking down the
                previous containers and reloading them. This causes them to
                automatically use the updated version of the image, and is a
                task that can be done in the AWS UI.
              </p>
              <h4 id="line9_4">Reference</h4>
              <p>
                This short guide will walk you through the process of deploying
                your React application to AWS using ECS (Elastic Container
                Service) and ECR (Elastic Container Registry). ECR is where you
                push your images, and ECS is the service that runs containers
                based on the images that are in ECR.
              </p>
              <strong>Prerequisites</strong>
              <ul>
                <li>— AWS account (first year free)</li>
                <li>— AWS CLI - install using `brew install awscli`</li>
                <li>— Docker</li>
              </ul>
              <strong>Step 1: Set Up AWS ECR in the AWS console</strong>
              <ol>
                <li>Go to ECR (under the Services tab).</li>
                <li>Click Create repository.</li>
                <li>Choose Private.</li>
                <li>Click Create repository.</li>
              </ol>
              <strong
                >Step 2: Containerize Your Frontend Application with
                Docker</strong
              >
              <ol>
                <li>
                  Create a Dockerfile at the root. Here's what it may look like:
                </li>
                <pre class="brush: bash">
# Step 1: Use Node.js image
FROM node:16 as build

# Step 2: Set working directory inside the container
WORKDIR /app

# Step 3: Copy the package files
COPY package*.json ./

# Step 4: Install dependencies
RUN npm install

# Step 5: Copy all the source files
COPY . .

# Step 6: Build the app for production
RUN npm run build

# Step 7: Serve the app (using a simple HTTP server)
FROM nginx:alpine
COPY --from=build /app/build /usr/share/nginx/html

# Expose port 80 for the app
EXPOSE 80

CMD ["nginx", "-g", "daemon off;"]
                </pre>
                <p>
                  This is setting out the instructions for what Docker should do
                  when it receives a request to construct your application into
                  an image.
                </p>
                <li>Run the following command at the root:</li>
                <pre class="brush: bash">
                    docker compose build
                </pre>
                <p>
                  This will tell Docker to construct your application into an
                  image.
                </p>
                <li>Login to AWS ECR using the following:</li>
                <pre class="brush: bash">
                    aws ecr get-login-password --region us-west-2 | docker login --username AWS --password-stdin {your_account_id}.dkr.ecr.us-west-2.amazonaws.com
                </pre>
                <p>
                  You can find your account ID in the top right of the AWS
                  dashboard.
                </p>
                <li>
                  Tag the image: Replace {your_account_id} with your AWS account
                  number and frontend-app with your repository name.
                </li>
                <pre class="brush: bash">
                    docker tag frontend-app:latest {your_account_id}.dkr.ecr.us-west-2.amazonaws.com/frontend-app:latest
                </pre>
                <li>
                  Push the Image to ECR: Push the image to your newly created
                  ECR repository:
                </li>
                <pre class="brush: bash">
                    docker push {your_account_id}.dkr.ecr.us-west-2.amazonaws.com/frontend-app:latest
                </pre>
              </ol>
              <strong>Step 3: Set Up AWS ECS</strong>
              <ol>
                <li>Go to ECS > Clusters and click Create Cluster.</li>
                <li>Choose Networking Only (Fargate) and click Next Step.</li>
                <li>
                  Name your cluster (e.g. frontend-cluster) and click Create.
                </li>
                <li>
                  Go to ECS > Task Definitions > Create New Task Definition.
                </li>
                <li>Choose Fargate.</li>
                <li>Name your task (e.g. frontend-task).</li>
                <li>
                  Set Task Memory to 0.5GB and Task CPU to 0.25 vCPU if that's
                  not default.
                </li>
                <li>
                  Under container definitions:
                  <ul>
                    <li>— Click Add container.</li>
                    <li>— Name the container (e.g., frontend-container).</li>
                    <li>
                      — Image: Use the ECR URI you pushed earlier, e.g.,
                      {your_account_id}.dkr.ecr.us-west-2.amazonaws.com/frontend-app:latest.
                    </li>
                    <li>
                      — Set the Port Mappings to 80:80 (container port 80 to the
                      host's port 80).
                    </li>
                    <li>— Click Add and then Create.</li>
                  </ul>
                </li>
                <li>
                  Create a service:
                  <ul>
                    <li>
                      — Go to ECS > Clusters > frontend-cluster > Services.
                    </li>
                    <li>- Click Create.</li>
                    <li>- Choose Fargate as the launch type.</li>
                    <li>
                      - Select your task definition (e.g., frontend-task).
                    </li>
                    <li>- Choose 1 Task.</li>
                    <li>
                      - Enable Auto-assign public IP under the Networking
                      section.
                    </li>
                    <li>- Choose the default VPC and public subnets.</li>
                    <li>- Click Next Step, and then Create Service.</li>
                  </ul>
                </li>
              </ol>
              <strong>Step 4: Set Up Security Groups and Networking</strong>
              <ol>
                <li>
                  Edit Security Group:
                  <ul>
                    <li>- Go to EC2 > Security Groups.</li>
                    <li>
                      - Find the security group attached to your ECS service.
                    </li>
                    <li>- Click Edit inbound rules.</li>
                    <li>
                      - Allow inbound traffic by creating a rule and setting the
                      source to 0.0.0.0/0.
                    </li>
                    <li>
                      - Go to ECS > Clusters > frontend-cluster > Services >
                      [Your Service].
                    </li>
                    <li>- Under Task, find the Public IP.</li>
                    <li>
                      Use that IP to access your frontend app, e.g.,
                      http://{public-ip}:80.
                    </li>
                  </ul>
                </li>
              </ol>
            </section>
            <!-- end section -->

            <section id="line10" class="section">
              <div class="row">
                <div class="col-md-12 left-align">
                  <h2 class="dark-text">
                    CI/CD
                    <p>Jamie Wells</p>
                    <hr />
                  </h2>
                  <p></p>
                </div>

                <!-- end col -->
              </div>
              <h4>GitHub Actions</h4>
              <p>
                Although we haven't quite finished our deployment process yet,
                we have clearly defined tasks that need to be complete before
                the newly-built image is pushed to Amazon ECR.
              </p>
              <a href="images/upload/github-actions.png" data-rel="prettyPhoto"
                ><img
                  src="images/upload/github-actions.png"
                  alt=""
                  class="img-responsive img-thumbnail"
              /></a>
              <p>
                Our GitHub actions pipeline is configured to run the initial
                tests that we've layed out using Pytest, and then if those tests
                pass, the pipeline will log into AWS using an automated IAM
                role, push our image to ECR, and finally deploy our containers
                on ECS.
              </p>
            </section>
            <!-- end section -->

            <section id="line11" class="section">
              <div class="row">
                <div class="col-md-12 left-align">
                  <h2 class="dark-text">
                    Looking Forward
                    <p>Jamie Wells</p>
                    <hr />
                  </h2>
                  <p></p>
                </div>

                <!-- end col -->
              </div>
              <h4>Enterprise API</h4>
              <p>
                As we've had to create multiple well-thought-out endpoints for
                interacting with our Mongo database, it would be
                straight-forward but effective to publicly release this API as
                an enterprise solution, providing API keys to users and
                integrating a rate limit.
              </p>
              <p>
                This would be useful for those who are looking to create an
                integrated messaging service within their own application, and
                due to the lightweight nature of our messaging service and
                database operations, we'd be able to offer this at a relatively
                low cost.
              </p>
              <h4>Database Caching</h4>
              <p>
                Another main feature we want to develop is database caching to
                decrease the overhead of regular database operations.
              </p>
              <p>
                Messaging on a messaging platform is a very frequent task. This
                is why I'm proposing that the database is not written to every
                time a message is sent, rather stored in a local cache, and the
                database written to in intervals.
              </p>
              <p>
                This process would involve updating a local variable that is
                stored server-side. This variable would lose its contents if the
                server shut down, had to restart etc, so we'd write the contents
                of this variable to a JSON file periodically.
              </p>
              <p>
                This way, we'd only have to access the database once on server
                start, and then use the persistent JSON storage to do all our
                data operations. Each table in the database would have a
                key-value pair variable in the following format:
              </p>
              <pre class="brush: js">
                {
                    "123456789x12345": "This is a message"
                }
              </pre>
              <p>
                Where the key is the unique ID of that entry, and the value is
                the primary data, so for a message the key would be the message
                content.
              </p>
              <p>
                We'd then have access methods which would be resonsible for
                updating the variables.
              </p>
              <pre class="brush: python">
def update(self, table: str, unique_id: str, title: str) -> Dict[str, str]:
    self.tables[table][unique_id] = title
    self._schedule_write(table)
    return {unique_id: title}
              </pre>
              <p>
                It's important to note that this would not work across multiple
                server instances, so we'd have to consider using a technology
                like Redis for persistent storage across instances.
              </p>
            </section>
          </div>
          <!-- // end .col -->
        </div>
        <!-- // end .row -->
      </div>
      <!-- // end container -->
    </div>
    <!-- end wrapper -->

    <script src="js/jquery.min.js"></script>
    <script src="js/bootstrap.min.js"></script>
    <script src="js/retina.js"></script>
    <script src="js/jquery.fitvids.js"></script>
    <script src="js/wow.js"></script>
    <script src="js/jquery.prettyPhoto.js"></script>

    <!-- CUSTOM PLUGINS -->
    <script src="js/custom.js"></script>
    <script src="js/main.js"></script>

    <script src="js/syntax-highlighter/scripts/shCore.js"></script>
    <script src="js/syntax-highlighter/scripts/shBrushXml.js"></script>
    <script src="js/syntax-highlighter/scripts/shBrushPython.js"></script>
    <script src="js/syntax-highlighter/scripts/shBrushBash.js"></script>
    <script src="js/syntax-highlighter/scripts/shBrushJScript.js"></script>
  </body>
</html>
