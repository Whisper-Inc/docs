<!doctype html>
<!--[if lt IE 7]><html class="ie ie6" lang="en"> <![endif]-->
<!--[if IE 7]><html class="ie ie7" lang="en"> <![endif]-->
<!--[if IE 8]><html class="ie ie8" lang="en"> <![endif]-->
<!--[if (gte IE 9)|!(IE)]><!-->
<html lang="en">
  <!--<![endif]-->

  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1"
    />
    <meta name="description" content="" />
    <meta name="author" content="" />
    <meta name="keywords" content="" />

    <title>Whisper Docs</title>

    <link rel="shortcut icon" href="images/favicon.webp" type="image/x-icon" />

    <link
      rel="stylesheet"
      type="text/css"
      href="fonts/font-awesome-4.3.0/css/font-awesome.min.css"
    />
    <link rel="stylesheet" type="text/css" href="css/stroke.css" />
    <link rel="stylesheet" type="text/css" href="css/bootstrap.css" />
    <link rel="stylesheet" type="text/css" href="css/animate.css" />
    <link rel="stylesheet" type="text/css" href="css/prettyPhoto.css" />
    <link rel="stylesheet" type="text/css" href="css/style.css" />

    <link
      rel="stylesheet"
      type="text/css"
      href="js/syntax-highlighter/styles/shCore.css"
      media="all"
    />
    <link
      rel="stylesheet"
      type="text/css"
      href="js/syntax-highlighter/styles/shThemeRDark.css"
      media="all"
    />

    <!-- CUSTOM -->
    <link rel="stylesheet" type="text/css" href="css/custom.css" />

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>

  <body>
    <button onclick="topFunction()" id="myBtn" title="Go to top">
      <i class="fa fa-chevron-up" aria-hidden="true"></i>
    </button>

    <script>
      var mybutton = document.getElementById("myBtn");
      window.onscroll = function () {
        scrollFunction();
      };
      function scrollFunction() {
        if (
          document.body.scrollTop > 1000 ||
          document.documentElement.scrollTop > 1000
        ) {
          mybutton.style.display = "block";
        } else {
          mybutton.style.display = "none";
        }
      }
      function topFunction() {
        window.scrollTo({ top: 0, behavior: "smooth" });
        document.documentElement.scrollTo({ top: 0, behavior: "smooth" });
      }

      document.addEventListener("DOMContentLoaded", () => {
        document.querySelector("#mode").addEventListener("click", () => {
          document.querySelector("html").classList.toggle("dark");
        });
      });
    </script>

    <div id="wrapper">
      <div id="mode">
        <div class="dark">
          <svg aria-hidden="true" viewBox="0 0 512 512">
            <title>lightmode</title>
            <path
              fill="currentColor"
              d="M256 160c-52.9 0-96 43.1-96 96s43.1 96 96 96 96-43.1 96-96-43.1-96-96-96zm246.4 80.5l-94.7-47.3 33.5-100.4c4.5-13.6-8.4-26.5-21.9-21.9l-100.4 33.5-47.4-94.8c-6.4-12.8-24.6-12.8-31 0l-47.3 94.7L92.7 70.8c-13.6-4.5-26.5 8.4-21.9 21.9l33.5 100.4-94.7 47.4c-12.8 6.4-12.8 24.6 0 31l94.7 47.3-33.5 100.5c-4.5 13.6 8.4 26.5 21.9 21.9l100.4-33.5 47.3 94.7c6.4 12.8 24.6 12.8 31 0l47.3-94.7 100.4 33.5c13.6 4.5 26.5-8.4 21.9-21.9l-33.5-100.4 94.7-47.3c13-6.5 13-24.7.2-31.1zm-155.9 106c-49.9 49.9-131.1 49.9-181 0-49.9-49.9-49.9-131.1 0-181 49.9-49.9 131.1-49.9 181 0 49.9 49.9 49.9 131.1 0 181z"
            ></path>
          </svg>
        </div>
        <div class="light">
          <svg aria-hidden="true" viewBox="0 0 512 512">
            <title>darkmode</title>
            <path
              fill="currentColor"
              d="M283.211 512c78.962 0 151.079-35.925 198.857-94.792 7.068-8.708-.639-21.43-11.562-19.35-124.203 23.654-238.262-71.576-238.262-196.954 0-72.222 38.662-138.635 101.498-174.394 9.686-5.512 7.25-20.197-3.756-22.23A258.156 258.156 0 0 0 283.211 0c-141.309 0-256 114.511-256 256 0 141.309 114.511 256 256 256z"
            ></path>
          </svg>
        </div>
      </div>

      <div class="container">
        <section id="top" class="section docs-heading">
          <div class="row">
            <div class="col-md-12">
              <div class="big-title text-center">
                <h1>Whisper Docs</h1>
                <p class="lead">Documentation version 1.0</p>
              </div>
              <!-- end title -->
            </div>
            <!-- end 12 -->
          </div>
          <!-- end row -->

          <hr />
        </section>
        <!-- end section -->

        <div class="row">
          <div class="col-md-3">
            <nav
              class="docs-sidebar"
              data-spy="affix"
              data-offset-top="300"
              data-offset-bottom="200"
              role="navigation"
            >
              <ul class="nav">
                <li>
                  <a href="#line-1">Introduction</a>
                </li>
                <li>
                  <a href="#line0">Team & Decisions</a>
                  <ul class="nav">
                    <li><a href="#line0_1">Role Definition</a></li>
                    <li><a href="#line0_2">Collaboration & Leadership</a></li>
                    <li><a href="#line0_3">Design Choices</a></li>
                  </ul>
                </li>
                <li><a href="#line1">Analysis</a></li>
                <li>
                  <a href="#line3">Project Setup</a>
                  <ul class="nav">
                    <li><a href="#line3_1">Organisation</a></li>
                    <li><a href="#line3_2">Repositories</a></li>
                    <li><a href="#line3_3">Kanban</a></li>
                  </ul>
                </li>
                <li>
                  <a href="#line4">UI Development</a>
                  <ul class="nav">
                    <li><a href="#line4_1">Inital Ideas and Components</a></li>
                    <li><a href="#line4_2">Integrating with Backend</a></li>
                    <li><a href="#line4_3">Login System and Web Socket Implementation</a></li>
                  </ul>
                </li>
                <li>
                  <a href="#line6">Database</a>
                  <ul class="nav">
                    <li><a href="#line6_1">Setup</a></li>
                    <li><a href="#line6_2">UserManager</a></li>
                    <li><a href="#line6_3">Endpoints</a></li>
                    <li><a href="#line6_4">Testing</a></li>
                  </ul>
                </li>
                <li>
                  <a href="#line7">Full-Stack Integration</a>
                </li>
                <li>
                  <a href="#line8">Writing Tests</a>
                  <ul class="nav">
                    <li><a href="#line8_1">Unit Tests</a></li>
                    <li><a href="#line8_2">End-to-End Tests</a></li>
                  </ul>
                </li>
                <li>
                  <a href="#line9">Deployment</a>
                  <ul class="nav">
                    <li><a href="#line9_1">Dockerisation</a></li>
                    <li><a href="#line9_2">Pushing to ECR</a></li>
                    <li><a href="#line9_3">Deploying on ECS</a></li>
                    <li><a href="#line9_4">Reference</a></li>
                  </ul>
                </li>
                <li><a href="#line10">CI/CD</a></li>
              </ul>
            </nav>
          </div>
          <div class="col-md-9">
            <section class="welcome">
              <div class="row">
                <div class="col-md-12 left-align">
                  <h2 class="dark-text" id="line-1">
                    Introduction
                    <hr />
                  </h2>
                  <div class="row">
                    <div class="col-md-12 full">
                      <div class="intro1">
                        <ul>
                          <li>
                            <strong>Authors : </strong>
                            Jamie Wells, Syed Abbas, Mahbubur (Hysam) Rahman, Samuel
                            Gagatek
                          </li>
                          <li>
                            <strong>License : </strong>
                            MIT
                          </li>
                        </ul>
                      </div>

                      <hr />
                      <div>
                        <h4>Welcome to Whisper!</h4>
                        <strong>What is Whisper?</strong>
                        <p>
                          Whisper is a lightweight messaging service designed
                          with scalability in mind above all else. We have built
                          Whisper with the intention of adding new features in
                          the future, but this documentation will cover the
                          basics of how we went from zero to a public MVP.
                        </p>

                        <h4>Requirements</h4>
                        <p>
                          You will need Docker installed to use this service
                          locally.
                        </p>
                        <div class="intro2 clearfix">
                          <p>
                            <i class="fa fa-exclamation-triangle"></i> Some of
                            the commands shown in the references (such as brew
                            install) will only be available on macOS and Linux
                            operating systems.
                            <br />
                          </p>
                        </div>
                      </div>
                    </div>
                  </div>
                  <!-- end row -->
                </div>
              </div>
            </section>

            <section id="line0" class="section">
              <div class="row">
                <div class="col-md-12 left-align">
                  <h2 class="dark-text">
                    Team and Decisions
                    <p>Samuel Gagatek</p>
                    <hr />
                  </h2>
                  <h4 id="line0_1">Role Definitions</h4>
  
                  <h5>Jamie Wells: Project Lead</h5>
                  <p>Jamie, our team leader was responsible for defining the project scope, delegating tasks, and maintaining overall project direction. In addition to leadership duties, he contributed to the project setup, configuration, and backend development.</p>
                  
                  <h5>Syed Abbas: UI/UX & Backend Integration</h5>
                  <p>Syed focused primarily on frontend development, working on React-based UI components while also configuring API endpoints to bridge frontend and backend functionality.</p>
                  
                  <h5>Mahbubur Rahman: Full Stack – Authentication Specialist</h5>
                  <p>Contributing across both backend and frontend, Hysam concentrated on the user authentication flow, including login and registration functionality, ensuring secure and smooth access to the system.</p>
                  
                  <h5>Samuel Gagatek: Backend & Testing</h5>
                  <p>Samuel worked mainly on backend logic and was instrumental in implementing and running automated tests. This ensured the stability of the codebase through unit and end-to-end testing.</p>



                  
                  <h4 id="line0_2">Collaboration & Leadership</h4>
                    <h4>GitHub Kanban Board</h4>
                    <p>We used a GitHub Kanban board to effectively delegate and manage tasks across our team. Each sprint was organized into clear milestones with tracked progress, ensuring alignment and accountability.</p>
                    
                    <h5>Sprint 1: Project Setup & Architecture</h5>
                    <img src="path/to/sprint1.png" alt="Sprint 1 image" />
                    <p>In Sprint 1, we focused on laying the foundation of the project. This included setting up the monorepo, CI/CD pipeline, database configuration and defining our tech stack across core and client services.</p>
                    
                    <h5>Sprint 2: Core Feature Development</h5>
                    <img src="path/to/sprint2.png" alt="Sprint 2 image" />
                    <p>During Sprint 2, we built out major features like authentication, chat creation, and message handling. The team worked across backend, frontend, and documentation to deliver functional user flows.</p>
                    
                    <h5>Sprint 3: Testing & Polishing</h5>
                    <img src="path/to/sprint3.png" alt="Sprint 3 image" />
                    <p>Sprint 3 focused on testing, bug fixes, and refining UX. We added unit and end-to-end tests to ensure the code was maintainable. We also fully completed our documentation for future reference.</p>


                  <h4 id="line0_2">Weekly Sprint Planning Meetings</h4>
                    <p>Each week, our team held structured sprint planning meetings over Zoom to coordinate efforts and keep the project on track. These meetings played a crucial role in our collaborative workflow and typically included the following:</p>
  
                    <ul>
                      <li><strong>Review of previous sprint:</strong> Discussed completed tasks, unresolved issues, and any blockers faced by the team.</li>
                      <li><strong>Task assignment:</strong> Delegated new tasks based on availability, expertise, and interest, ensuring balanced workloads.</li>
                      <li><strong>Kanban board updates:</strong> Moved cards across columns (To Do, In Progress, Done) and added new issues or features to track.</li>
                      <li><strong>Technical discussions:</strong> Talked through implementation plans, design decisions, or architectural considerations.</li>
                      <li><strong>Goal setting:</strong> Aligned on priorities and deliverables for the upcoming sprint to maintain focus and momentum.</li>
                    </ul>
                    
                    <p>These meetings promoted transparency, allowed for real-time collaboration, and helped the team stay synchronized throughout the development process.</p>

                  <h4 id="line0_3">Code Reviews & Collaboration</h4>
                    <p>Our team emphasized the importance of code reviews as a key part of our development workflow. Every pull request was reviewed by at least one other team member before being merged into the main branch. This not only helped catch bugs early but also ensured consistency in code quality, style, and design decisions across the project.</p>
                    
                    <p>Code reviews provided a valuable opportunity for team members to:</p>
                    <ul>
                      <li><strong>Share knowledge:</strong> Reviewing each other's code helped everyone stay familiar with different parts of the codebase.</li>
                      <li><strong>Maintain consistency:</strong> We followed agreed-upon conventions and design patterns, which were reinforced during review.</li>
                      <li><strong>Improve code quality:</strong> Suggestions and feedback often led to better performance, readability, and maintainability.</li>
                      <li><strong>Encourage collaboration:</strong> Discussions in review threads fostered healthy team communication and problem-solving.</li>
                    </ul>
                    
                    <p>We used GitHub’s pull request system to manage reviews, assign reviewers, and track changes. This workflow ensured that all team members were engaged in each other’s work and contributed to the overall quality of the project.</p>


                  <h4 id="line0_3">Design Choices</h4>
                  <h4>Whisper Inc Organisation - Our monorepository</h4>
              
                  <h5>Whisper Core</h5>
                  <img src="path/to/whisper-core.png" alt="Whisper Core image" />
                  <p>Whisper Core is the repository that houses the backend of our service. 
                    It handles authentication, chat logic, data storage, and API endpoints for client communication.</p>
                  
                  <h5>Whisper Client</h5>
                  <img src="path/to/whisper-client.png" alt="Whisper Client image" />
                  <p>Whisper Client is the frontend application used by users to interact with the platform. 
                    Built with modern frameworks, it provides real-time messaging with individuals and groups, all while maintaining a modern and sleek user interface.</p>
    
                  <h5>Docs</h5>
                  <img src="path/to/docs.png" alt="Docs image" />
                  <p>Docs is the documentation hub for Whisper Inc. 
                    It contains developer guides, API references and architecture overviews to help team members navigate the codebase.</p>

                  <h4 id="line0_2">Why We Chose Python</h4>
                    <p>We chose <strong>Python</strong> for our backend development due to its simplicity, readability, and wide adoption in web development. Python’s vast ecosystem of libraries, particularly for APIs and database management, allowed us to move quickly and build a solid backend foundation. Its clean syntax made collaboration between team members easy, especially when developing or reviewing code.</p>
                    
                    <h4 id="line0_3">Why We Chose React</h4>
                    <p>On the frontend, we selected <strong>React</strong> because of its component-based architecture, responsive rendering, and strong developer community. React allowed us to break down the UI into reusable, maintainable components that made the app easier to scale and test. Its seamless integration with modern styling libraries and state management tools also helped speed up development and enhance user experience.</p>
                    
                    <h4 id="line0_4">Why We Chose MongoDB</h4>
                    <p>We selected MongoDB as our database solution due to its developer-friendly features and seamless integration with Python. The <strong>PyMongo</strong> API made it easy to interact with the database using native Python syntax, which reduced complexity and sped up backend development. Additionally, MongoDB’s <strong>lightweight, schema-less structure</strong> allowed us to iterate on our data models quickly without worrying about rigid table definitions. The clean and intuitive user interface provided by <strong>MongoDB Atlas</strong> also made it easy to visualize, manage, and debug data during development.</p>
                    
                    <h4 id="line0_5">Why We Chose FastAPI Over Flask</h4>
                    <p>We chose <strong>FastAPI</strong> for our backend framework instead of Flask primarily due to its built-in support for <strong>asynchronous request handling</strong>, which enables better performance and scalability. FastAPI’s use of modern Python features like type hints and Pydantic models helped us write more robust, self-validating code while improving code clarity and autocompletion.</p>

    
                </div>
                <!-- end col -->
              </div>
            </section>
            <!-- end section -->

            <section id="line1" class="section">
              <div class="row">
                <div class="col-md-12 left-align">
                  <h2 class="dark-text">
                    Analysis
                    <p>Syed Abbas</p>
                    <hr />
                  </h2>
                </div>
                <!-- end col -->
              </div>
              <!-- end row -->

              <div class="row">
                <div class="col-md-12">
                  <h4>Stakeholders</h4>
                  <p>
                    The primary stakeholders for this messaging service are
                    teenage students, mainly in school, who use the platform to
                    stay connected with friends both during and outside of
                    school hours. The app supports communication around
                    homework, class projects, and planning social activities
                    like get-togethers or study groups. These users value quick,
                    easy, and fun ways to chat—whether one-on-one or in group
                    chats—with options to personalize their profiles and manage
                    privacy.
                  </p>

                  <h4>User Stories</h4>

                  <strong>Messaging</strong>
                  <ul>
                    <li>
                      Users can send and receive real-time messages with read
                      receipts and timestamps.
                    </li>
                    <li>
                      Users get notified of new messages and can track message
                      status (sent, delivered, read).
                    </li>
                  </ul>

                  <strong>Group Chats</strong>
                  <ul>
                    <li>Users can create group chats and name them.</li>
                    <li>
                      Users can add or remove members and view a list of
                      participants.
                    </li>
                  </ul>

                  <strong>Account & Personalisation</strong>
                  <ul>
                    <li>
                      Users can create and log into their accounts securely.
                    </li>
                    <li>
                      Users can manage account details like passwords and logout
                      when needed.
                    </li>
                  </ul>

                  <strong>Settings & Preferences</strong>
                  <ul>
                    <li>Users can customize notification settings</li>
                  </ul>

                  <h4>Design</h4>
                  <p>
                    To come up with a basic design, we deiced to discuss the
                    requirements and then explore how we can apply an
                    architecture
                  </p>

                  <strong>Architecture Style</strong>

                  <strong>Mircroservices Achitecure</strong>
                  <p>
                    The system is designed using microservices, allowing the
                    frontend and backend to be developed, deployed, and scaled
                    independently. Each service is responsible for a specific
                    function, improving flexibility and scalability.
                  </p>

                  <strong>Frontend Mircoservice (MVC)</strong>
                  <p>
                    Model: Represents the user interface data—like messages,
                    chat history, user profiles, and settings. The model
                    contains the necessary information for display but doesn't
                    directly handle user actions.
                  </p>
                  <p>
                    View: The UI components that the user interacts with,chat
                    rooms, buttons, and settings. This layer is responsible for
                    rendering data to the user in a way that's easy to
                    understand.
                  </p>
                  <p>
                    Controller: The logic layer that processes user inputs, such
                    as sending messages, joining group chats, or updating
                    profiles. It communicates with the backend to fetch data or
                    send requests and updates the view accordingly.
                  </p>

                  <strong>Backend Mircoservice (MVC)</strong>
                  <p>
                    Model: Contains the business logic and data structure, such
                    as user authentication, message storage, and group chat
                    management. It manages interactions with the database.
                  </p>
                  <p>
                    View: The API responses that the frontend receives from the
                    backend. These views are not directly presented to the user
                    but are the data structures (like JSON) that are returned to
                    the frontend for rendering.
                  </p>
                  <p>
                    Controller: The API controllers that handle incoming
                    requests from the frontend, such as creating accounts,
                    sending messages, or updating group chats. The controller
                    processes requests, interacts with the model (business
                    logic), and returns the necessary data (view) to the
                    frontend.
                  </p>

                  <strong>Database</strong>
                  <p>
                    Centralised storage for data. The database stores the
                    following:
                  </p>
                  <ul>
                    <li>User accounts (authentication details)</li>
                    <li>Messages</li>
                    <li>Chats</li>
                  </ul>
                </div>
                <!-- end col -->
              </div>
              <!-- end row -->
            </section>
            <!-- end section -->

            <section id="line2" class="section">
              <div class="row">
                <div class="col-md-12 left-align">
                  <h2 class="dark-text">
                    Choosing Technologies
                    <p>Mahbubur Rahman</p>
                    <hr />
                  </h2>
                </div>
                <!-- end col -->
              </div>
              <!-- end row -->

              <div class="intro2 clearfix">
                <p>
                  <i class="fa fa-wordpress"></i> Lorem the It is a long
                  established fact that a reader will be distracted.. <br />
                  Please read more about WordPress here.
                  <a href="#">WordPress Installation via FTP.</a>
                </p>
              </div>

              <hr />

              <h4>Upload via WordPress Admin</h4>

              <p>
                Lorem the It is a long established fact that a reader will be
                distracted by the readable content of a page when looking at its
                layout. The point of using Lorem Ipsum is that it has a
                more-or-less normal distribution of letters, as opposed to using
                'Content here, content here', making it look like readable
                English.
              </p>

              <a href="#" class="btn btn-primary">Get a Installation Service</a>
              <a href="#" class="btn btn-info">Ask a Question</a>
              <hr />
              <div class="row">
                <div class="col-md-8 col-md-offset-2">
                  <div class="media">
                    <iframe
                      width="560"
                      height="315"
                      src="https://www.youtube.com/embed/snFzbPm_RUE"
                      frameborder="0"
                      allowfullscreen
                    ></iframe>
                  </div>
                </div>
              </div>
            </section>
            <!-- end section -->

            <section id="line3" class="section">
              <div class="row">
                <div class="col-md-12 left-align">
                  <h2 class="dark-text">
                    Project Setup
                    <p>k</p>
                    <hr />
                  </h2>
                </div>
                <!-- end col -->
              </div>
              <!-- end row -->

              <h4>Whisper Inc Organisation</h4>
              
              <h5>Whisper Core</h5>
              <img src="path/to/whisper-core.png" alt="Whisper Core image" />
              <p>Whisper Core is the repository that houses the backend of our service. 
                It handles authentication, chat logic, data storage, and API endpoints for client communication.</p>
              
              <h5>Whisper Client</h5>
              <img src="path/to/whisper-client.png" alt="Whisper Client image" />
              <p>Whisper Client is the frontend application used by users to interact with the platform. 
                Built with modern frameworks, it provides real-time messaging with individuals and groups, all while maintaining a modern and sleek user interface.</p>

              <h5>Docs</h5>
              <img src="path/to/docs.png" alt="Docs image" />
              <p>Docs is the documentation hub for Whisper Inc. 
                It contains developer guides, API references and architecture overviews to help team members navigate the codebase.</p>

              <h4>GitHub Kanban Board</h4>
              <p>We used a GitHub Kanban board to effectively delegate and manage tasks across our team. Each sprint was organized into clear milestones with tracked progress, ensuring alignment and accountability.</p>
              
              <h5>Sprint 1: Project Setup & Architecture</h5>
              <img src="path/to/sprint1.png" alt="Sprint 1 image" />
              <p>In Sprint 1, we focused on laying the foundation of the project. This included setting up the monorepo, CI/CD pipeline, database configuration and defining our tech stack across core and client services.</p>
              
              <h5>Sprint 2: Core Feature Development</h5>
              <img src="path/to/sprint2.png" alt="Sprint 2 image" />
              <p>During Sprint 2, we built out major features like authentication, chat creation, and message handling. The team worked across backend, frontend, and documentation to deliver functional user flows.</p>
              
              <h5>Sprint 3: Testing & Polishing</h5>
              <img src="path/to/sprint3.png" alt="Sprint 3 image" />
              <p>Sprint 3 focused on testing, bug fixes, and refining UX. We added unit and end-to-end tests to ensure the code was maintainable. We also fully completed our documentation for future reference.</p>


              <hr />
              <hr />
              <div class="row">
                <div class="col-md-6">
                  <div class="media">
                    <iframe
                      width="560"
                      height="315"
                      src="https://www.youtube.com/embed/yQnQyI5WlKs"
                      frameborder="0"
                      allowfullscreen
                    ></iframe>
                  </div>
                </div>
                <div class="col-md-6">
                  <div class="media">
                    <iframe
                      width="560"
                      height="315"
                      src="https://www.youtube.com/embed/z0kEVwJB_go"
                      frameborder="0"
                      allowfullscreen
                    ></iframe>
                  </div>
                </div>
              </div>
            </section>
            <!-- end section -->

            <section id="line4" class="section">
              <div class="row">
                <div class="col-md-12 left-align">
                  <h2 class="dark-text">
                    UI Development
                    <p>Syed Abbas</p>
                    <hr />
                  </h2>
                </div>
                <!-- end col -->
              </div>
              <!-- end row -->

                <div class="col-md-12">
                  <h2 id="line4_1" class=font>Initial Ideas and Components</h2>
                  <p>
                    As dicussed previously, for the user interface we as a group have decided to use React Js with NextJs and Typescript. For styling, we have decided to use TailwindCSS. I have taken the role to be the main frontend developer in the group.
                    To start off, I looked at the designs ad user intefaces for other messaging service applications such as Mircrosoft Teams. With this, I was able to decide on the main components that I would need to create
                    for a foundational structure that can be built on.
                  </p>
                  
                  <h4>Components for Basic Structure</h4>
                  <p>As we are following MVC, these are our main view components</p>

                  <div class="row d-flex align-items-stretch text-center">
                  
                       <!-- Sidebar -->
                    <div class="col-md-4 mb-4 d-flex">
                      <div class="card w-100 h-100">
                        <img
                          src="images/upload/sidebar.png"
                          class="card-img-top img-fluid"
                          alt="Sidebar"
                          style="height: 200px; object-fit: cover"
                        />
                        <div class="card-body d-flex flex-column">
                          <h5 class="card-title">Sidebar</h5>
                          <p class="card-text">
                            Having this as part of the basic structure is crucial, as it will be the component that allows the users to interact with the application and access different pages such as settings or group chats. Therefore, features
                            will be built on top of this. After discussing with the team, we have decided to only have 3 menus. Direct will allow users to access any priavte chats they may have. Group chats will allow users to access any other chats they may
                            have with multiple people. The settings menu will allow users to access profile and notifications settings.
                          </p>
                        </div>
                      </div>
                    </div>

                    <!-- Chat List -->
                    <div class="col-md-4 mb-4 d-flex">
                      <div class="card w-100 h-100">
                        <img
                          src="images/upload/chatlist.png"
                          class="card-img-top img-fluid"
                          alt="Chat List"
                          style="height: 200px; object-fit: cover"
                        />
                        <div class="card-body d-flex flex-column">
                          <h5 class="card-title">Chat List</h5>
                          <p class="card-text">
                            This component will allow users to access and their chats. This is another main components as further functionality will be built on top, such as accesssing specific chat messages and loading chats from API's. Using the search bar at the top
                            users will be able to search for specific chats and filter the list accordingly. To start off, I have decided to use mock data to ensure and test that the chats are displayed appropriatelty. Later, I will be using GET requests to
                            fetch chats from the backend.
                          </p>
                        </div>
                      </div>
                    </div>
                    
                    <!-- Chat Window -->
                    <div class="col-md-4 mb-4 d-flex">
                      <div class="card w-100 h-100">
                        <img
                          src="images/upload/chatwindow.png"
                          class="card-img-top img-fluid"
                          alt="Chat Window"
                          style="height: 200px; object-fit: cover"
                        />
                        <div class="card-body d-flex flex-column">
                          <h5 class="card-title">Chat Window</h5>
                          <p class="card-text">
                            This component will allow users to access their chat messages and edit their chat to add and remove people, hence being another main component, as features will be implmeneted later on. 
                            As a start, I am using mock data for the chat messages to test and ensure they are displayed properly. This makes it easier for me to apply the css styling.
                          </p>
                        </div>
                      </div>
                    </div>
                  </div>

                  <h4>Chat Modal Implementation</h4>
                  <p>For users to be able to create chats and update them, I decided to create a modal which can update.</p>
                  <p>In the modal, users can:</p>
                  <ul>
                    <li>Add participants to group chats</li>
                    <li>Name the chat</li>
                    <li>Remove participants</li>
                  </ul>
                  <a href="images/upload/updatechatmodal.png" data-rel="prettyPhoto"
                  ><img
                        src="images/upload/updatechatmodal.png"
                        alt=""
                        class="img-responsive img-thumbnail"
                        style="width: 75%; max-width: 500px; margin: 1rem auto; display: block;"
                      />
                  </a>
                  <p>The same modal component is used to create and update chats. In the chat list, there is a 'New Chat' button and in the chat window component there is an 'Edit' button to add or remove participants</p>
                  <a href="images/upload/updatechatmodal2.png" data-rel="prettyPhoto"
                  ><img
                        src="images/upload/updatechatmodal2.png"
                        alt=""
                        class="img-responsive img-thumbnail"
                        style="width: 75%; max-width: 500px; margin: 1rem auto; display: block;"
                      />
                  </a>
                  
                  <h2 id="line4_2">Integrating with Backend</h2>
                  <p>As our main components have been developed, I now moved onto creating model components to define requests and responses that will be sent to the backend API endpoints.</p>
                  <p>Here is an exmple of create chat request:</p>
                  <pre class="brush: js">
                  public async createGroupChat(
                      initiator: string,
                      participants: string[],
                      chatName: string
                  ): Promise<string> {
                      const requestBody = {
                          initiator: initiator,
                          chat_name: chatName,
                          participants: participants,
                          is_group: true,
                      };
                  </pre>
                  <p>I have also defined controller components that will be sending the actual requests to to the backend endpoins. The controller then uses the model to process the data and
                  communicates this with the view components so that the data can be displayed accordingly:</p>

                  <pre class="brush: js">
                    try {
                      const response = await fetch(`${process.env.NEXT_PUBLIC_API_URL}create-chat`, {
                          method: "POST",
                          headers: {
                              "Content-Type": "application/json",
                          },
                          body: JSON.stringify(requestBody),
                      });
          
                      if (!response.ok) {
                          throw new Error("Failed to create chat");
                      }
                      const responseData = await response.json();
                  </pre>

          
                <h2 id="line4_3">Login System and Web Socket Implementation</h2>
                  

                  
              
                </div>
          
              <!-- end row -->
            </section>
            <!-- end section -->

            <section id="line6" class="section">
              <div class="row">
                <div class="col-md-12 left-align">
                  <h2 class="dark-text">
                    Database
                    <p>Jamie Wells</p>
                    <hr />
                  </h2>
                </div>
                <!-- end col -->
              </div>
              <h4 id="line6_1">Setup</h4>
              <p>
                After deciding that we'd use MongoDB for our database
                operations, we got started by exploring the UI and some of the
                documentation that Mongo has laid out. Initially, we set up two
                databases—one for development, and one for production.
              </p>
              <a href="images/upload/mongo.png" data-rel="prettyPhoto"
                ><img
                  src="images/upload/mongo.png"
                  alt=""
                  class="img-responsive img-thumbnail"
              /></a>
              <p>
                At first, we had difficulty connecting with this online
                instance. We had successfully established a connection, were
                able to create tables and insert entries into these tables, but
                we realised that this was only on a local instance. We quickly
                changed our connection string to reflect that of the online
                instance, by using the command:
              </p>
              <pre class="brush: bash">
mongosh "mongodb+srv://{username}:{password}@whispercluster.e03b9.mongodb.net/dev?retryWrites=true&w=majority&appName=WhisperCluster"
              </pre>
              <p>
                This command would connect us to the online instance and allow
                us to propogate our requests externally.
              </p>
              <h4 id="line6_2">UserManager</h4>
              <p>
                The MongoUserManager class is where the PyMongo helper methods
                are defined. When the server starts up, only one instance of
                MongoUserManager will be created (when the app settings are
                defined), which is much more memory efficient than creating a
                new object for each incoming request.
              </p>
              <p>
                These requests are then handled by the endpoints defined, and
                use the helper functions to receive outputs on the request data,
                where the request data is parsed in as arguments.
              </p>
              <p>
                Below is an example of how our register user endpoint uses the
                register user method in MongoUserManager to execute the
                necessary database operations:
              </p>
              <pre class="brush: python">
@app.post("/register")
async def register(request: models.RegisterRequest):
    try:
        # Validate input
        if not request.username or not request.password:
            raise HTTPException(
                status_code=400, detail="Username and password are required"
            )

        # attempting to register user
        response = config.user_manager.register_user(request.username, request.password)
        if response:
            config.logger.info("User registered successfully")
            return {"message": "User registered successfully"}
        (...)
              </pre>
              <p>
                This method will get the user details from the request and use
                the register_user method in the MongoUserManager class to
                execute the database logic and return the result. This
                particular method returns a boolean, indicating whether the user
                registration was successful or not:
              </p>
              <pre class="brush: python">
def register_user(self, username: str, password: str) -> bool:
    user_exists = self.users_collection.find_one({"username": username})

    if user_exists:
        return False

    hashed_password = bcrypt.hashpw(password.encode("utf-8"), bcrypt.gensalt())

    user_document = {
        "username": username,
        "password": hashed_password,
        "created_at": time.time(),
    }
    self.users_collection.insert_one(user_document)
    self.config.logger.info("\nUser added to DB")
    return True
              </pre>
              <br />
              <h4 id="line6_3">Endpoints</h4>
              <p>
                The pymongo API logic had now been written, and the next step
                was writing request handlers that would operate on this logic.
                Here is an example of one of the endpoints we have for logging
                in:
              </p>
              <pre class="brush: python">
@app.post("/login")
async def login(request: models.LoginRequest):
    """User login endpoint."""
    try:
        # Validate credentials
        if config.user_manager.validate_user(request.username, request.password):
            # Generate and return login token
            token = config.user_manager.generate_token(request.username)
            return {"token": token, "username": request.username}
        else:
            raise HTTPException(status_code=401, detail="Invalid credentials")
    except Exception as e:
        config.logger.error(f"Login error: {e}")
        raise HTTPException(status_code=500, detail="Login failed")
              </pre>
              <p>
                This endpoint will take the LoginRequest pydantic model that
                we've defined as a parameter, use the helper functions defined
                in the UserManager class to validate that the user's credentials
                can be registered, generate a web token associated with the user
                and return it in the response.
              </p>
              <p>
                It's worth noting that we have also written comprehensive
                documentation on each endpoint, including how to call it, what
                it's expecting in the request body, and what it returns. This
                documentation takes the form of a README.md file in our backend
                repository.
              </p>
              <a href="images/upload/endpoints.png" data-rel="prettyPhoto"
                ><img
                  src="images/upload/endpoints.png"
                  alt=""
                  class="img-responsive img-thumbnail"
              /></a>
              <br />
              <br />
              <h4 id="line6_4">Testing</h4>
              <p>
                Now that the database had been set up and the request handlers
                for communicating to the database had been committed, it was
                time to start sending test requests to these endpoints.
              </p>
              <p>
                In order to this, we had two options. We could run copy and
                paste the localhost URL into the browser and add the endpoint we
                wanted to hit onto the end, but this wouldn't work for any
                request that required a request body or request header. To solve
                this, we used Postman, where we could customise the request
                type, body, and headers.
              </p>
              <a href="images/upload/postman.png" data-rel="prettyPhoto"
                ><img
                  src="images/upload/postman.png"
                  alt=""
                  class="img-responsive img-thumbnail"
              /></a>
              <p>
                By being able to add custom headers to each request, this would
                allow us to authenticate necessary requests with a custom
                Whisper API key so that users couldn't make unauthenticated
                requets. For our automated end-to-end tests, please see
                <a href="#line8">Writing Tests</a>.
              </p>
            </section>
            <!-- end section -->

            <section id="line7" class="section">
              <div class="row">
                <div class="col-md-12 left-align">
                  <h2 class="dark-text">
                    Full-Stack Integration
                    <p>Mahbubur Rahman</p>
                    <hr />
                  </h2>
                </div>
                <!-- end col -->
              </div>
              <!-- end row -->
              <h4 id="line7_1">Placeholder</h4>
              <p>Placeholder</p>
            </section>
            <!-- end section -->

            <section id="line8" class="section">
              <div class="row">
                <div class="col-md-12 left-align">
                  <h2 class="dark-text">
                    Writing Tests
                    <p>Samuel Gagatek</p>
                    <hr />
                  </h2>
                </div>
                <!-- end col -->
              </div>
            <h4 id="line8_1">Unit Tests</h4>
            <img src="path/to/unit-tests.png" alt="Unit tests image" />
            <p>Our project includes a robust suite of unit tests designed to ensure core logic works as expected across both backend and frontend systems. For the backend, we created focused unit tests, using pytest, around the <strong>MongoUserManager</strong> class, which handles database interactions such as user creation, chat management, and message storage. These tests mock MongoDB responses to validate logic without needing a real database connection.</p>
            
            <p>On the frontend, we used <strong>TypeScript unit tests</strong> to validate UI components, input validation, and utility functions. These tests help catch logic issues early and ensure consistent rendering and behavior in the React-based Whisper Client interface.</p>
            
            <h4 id="line8_2">End-to-End Tests</h4>
            <img src="path/to/e2e-tests.png" alt="End-to-End tests image" />
            <p>Our <strong>end-to-end (E2E) tests</strong> simulate real user interactions and validate the system as a whole. Written in Python using <strong>pytest</strong>, these tests interact with live API endpoints, ensuring that requests and responses interact correctly with the MongoDB database.</p>
            
            <p>Each E2E test covers scenarios like chat creation, user login, message sending, and permission validation. These tests help verify integration between components and provide high confidence that the endpoints behave correctly in production-like environments.</p>

            <h4 id="line8_3">How to Run the Tests</h4>
            <p>To ensure the stability and reliability of our application, we’ve set up both unit and end-to-end test suites. You can run them locally using the following commands:</p>
            
            <h5>🧪 Backend Unit Tests (Python)</h5>
            <pre><code>pytest tests/unit_tests</code></pre>
            
            <h5>🚀 End-to-End Tests (Python)</h5>
            <pre><code>pytest tests/end_to_end_tests</code></pre>
            
            <h5>🧩 Frontend Unit Tests (TypeScript)</h5>
            <pre><code>npm run test</code></pre>

            <h5> Testing in VSCode</h5>
              <p> VSCode (and potentially other IDEs allow you to seamlessly run all your tests. Use the 'Testing' button to run all the tests, like the example below.</p>
            
            <p>Make sure you have all necessary dependencies installed and any required services (like MongoDB) running if applicable. Running the full suite regularly helps catch regressions early and ensures all features continue to work as expected.</p>

            </section>
            <!-- end section -->

            <section id="line9" class="section">
              <div class="row">
                <div class="col-md-12 left-align">
                  <h2 class="dark-text">
                    Deployment
                    <p>Jamie Wells</p>
                    <hr />
                  </h2>
                </div>
                <!-- end col -->
              </div>
              <!-- end row -->

              <h4 id="line9_1">Dockerisation</h4>
              <p>
                We decided that we would deploy our application through building
                an image, and deploying containers using that image. We would
                use Docker for this, as it was relatively straightforward to use
                and would integrate with AWS easily.
              </p>
              <p>
                The first step was creating a Dockerfile that we could run with
                Docker to build an image of our application. We decided to use a
                lightweight Python base image so that build times would be
                minimised. As we didn't need the extra features, this would
                decrease our build time by about 80% from 50 seconds to ~10
                seconds whilst maintaining all the functionality that we needed.
              </p>
              <pre class="brush: bash">
FROM python:3.13-slim

WORKDIR /app
COPY . /app

RUN pip install --no-cache-dir -r requirements.txt

CMD ["uvicorn", "app:app", "--host", "0.0.0.0", "--port", "8000"]
              </pre>
              <p>
                The next task was to construct a .yml file that would build and
                deploy our containers. We created two services; one for our
                FastAPI application, and one for our Mongo instance. We set it
                up so that our FastAPI container would depend on the container
                hosting Mongo, so that if container two was down, container one
                would no longer try and operate as normal, as this would cause
                connection issues with the database.
              </p>
              <h4 id="line9_2">Pushing to ECR</h4>
              <p>
                After a commit, if you want your changes to be reflected in your
                production service, you must rebuild your Docker image and push
                it to AWS ECR. You can do both these things by running the
                following command:
              </p>
              <pre class="brush: bash">
docker buildx build \
--platform linux/amd64 \
-t 374544621977.dkr.ecr.eu-west-2.amazonaws.com/whisper/core:latest \
--push .
              </pre>
              This will tell Docker to rebuild your image with the latest
              changes - because we are using a lightweight Python base image,
              this only took a few seconds. After the image has rebuilt itself
              to reflect the latest changes, it will push this image to ECR,
              which means that AWS has now been successfully updated to use the
              newest version of your application.
              <h4 id="line9_3">Deploying to ECS</h4>
              <p>
                The final step in the deployment process is spinning up new
                containers that are using the image hosting the updated version
                of our application. This is a simple case of taking down the
                previous containers and reloading them. This causes them to
                automatically use the updated version of the image, and is a
                task that can be done in the AWS UI.
              </p>
              <h4 id="line9_4">Reference</h4>
              <p>
                This short guide will walk you through the process of deploying
                your React application to AWS using ECS (Elastic Container
                Service) and ECR (Elastic Container Registry). ECR is where you
                push your images, and ECS is the service that runs containers
                based on the images that are in ECR.
              </p>
              <strong>Prerequisites</strong>
              <ul>
                <li>— AWS account (first year free)</li>
                <li>— AWS CLI - install using `brew install awscli`</li>
                <li>— Docker</li>
              </ul>
              <strong>Step 1: Set Up AWS ECR in the AWS console</strong>
              <ol>
                <li>Go to ECR (under the Services tab).</li>
                <li>Click Create repository.</li>
                <li>Choose Private.</li>
                <li>Click Create repository.</li>
              </ol>
              <strong
                >Step 2: Containerize Your Frontend Application with
                Docker</strong
              >
              <ol>
                <li>
                  Create a Dockerfile at the root. Here's what it may look like:
                </li>
                <pre class="brush: bash">
                    # Step 1: Use Node.js image
FROM node:16 as build

# Step 2: Set working directory inside the container
WORKDIR /app

# Step 3: Copy the package files
COPY package*.json ./

# Step 4: Install dependencies
RUN npm install

# Step 5: Copy all the source files
COPY . .

# Step 6: Build the app for production
RUN npm run build

# Step 7: Serve the app (using a simple HTTP server)
FROM nginx:alpine
COPY --from=build /app/build /usr/share/nginx/html

# Expose port 80 for the app
EXPOSE 80

CMD ["nginx", "-g", "daemon off;"]
                </pre>
                <p>
                  This is setting out the instructions for what Docker should do
                  when it receives a request to construct your application into
                  an image.
                </p>
                <li>Run the following command at the root:</li>
                <pre class="brush: bash">
                    docker compose build
                </pre>
                <p>
                  This will tell Docker to construct your application into an
                  image.
                </p>
                <li>Login to AWS ECR using the following:</li>
                <pre class="brush: bash">
                    aws ecr get-login-password --region us-west-2 | docker login --username AWS --password-stdin {your_account_id}.dkr.ecr.us-west-2.amazonaws.com
                </pre>
                <p>
                  You can find your account ID in the top right of the AWS
                  dashboard.
                </p>
                <li>
                  Tag the image: Replace {your_account_id} with your AWS account
                  number and frontend-app with your repository name.
                </li>
                <pre class="brush: bash">
                    docker tag frontend-app:latest {your_account_id}.dkr.ecr.us-west-2.amazonaws.com/frontend-app:latest
                </pre>
                <li>
                  Push the Image to ECR: Push the image to your newly created
                  ECR repository:
                </li>
                <pre class="brush: bash">
                    docker push {your_account_id}.dkr.ecr.us-west-2.amazonaws.com/frontend-app:latest
                </pre>
              </ol>
              <strong>Step 3: Set Up AWS ECS</strong>
              <ol>
                <li>Go to ECS > Clusters and click Create Cluster.</li>
                <li>Choose Networking Only (Fargate) and click Next Step.</li>
                <li>
                  Name your cluster (e.g. frontend-cluster) and click Create.
                </li>
                <li>
                  Go to ECS > Task Definitions > Create New Task Definition.
                </li>
                <li>Choose Fargate.</li>
                <li>Name your task (e.g. frontend-task).</li>
                <li>
                  Set Task Memory to 0.5GB and Task CPU to 0.25 vCPU if that's
                  not default.
                </li>
                <li>
                  Under container definitions:
                  <ul>
                    <li>— Click Add container.</li>
                    <li>— Name the container (e.g., frontend-container).</li>
                    <li>
                      — Image: Use the ECR URI you pushed earlier, e.g.,
                      {your_account_id}.dkr.ecr.us-west-2.amazonaws.com/frontend-app:latest.
                    </li>
                    <li>
                      — Set the Port Mappings to 80:80 (container port 80 to the
                      host's port 80).
                    </li>
                    <li>— Click Add and then Create.</li>
                  </ul>
                </li>
                <li>
                  Create a service:
                  <ul>
                    <li>
                      — Go to ECS > Clusters > frontend-cluster > Services.
                    </li>
                    <li>- Click Create.</li>
                    <li>- Choose Fargate as the launch type.</li>
                    <li>
                      - Select your task definition (e.g., frontend-task).
                    </li>
                    <li>- Choose 1 Task.</li>
                    <li>
                      - Enable Auto-assign public IP under the Networking
                      section.
                    </li>
                    <li>- Choose the default VPC and public subnets.</li>
                    <li>- Click Next Step, and then Create Service.</li>
                  </ul>
                </li>
              </ol>
              <strong>Step 4: Set Up Security Groups and Networking</strong>
              <ol>
                <li>
                  Edit Security Group:
                  <ul>
                    <li>- Go to EC2 > Security Groups.</li>
                    <li>
                      - Find the security group attached to your ECS service.
                    </li>
                    <li>- Click Edit inbound rules.</li>
                    <li>
                      - Allow inbound traffic by creating a rule and setting the
                      source to 0.0.0.0/0.
                    </li>
                    <li>
                      - Go to ECS > Clusters > frontend-cluster > Services >
                      [Your Service].
                    </li>
                    <li>- Under Task, find the Public IP.</li>
                    <li>
                      Use that IP to access your frontend app, e.g.,
                      http://{public-ip}:80.
                    </li>
                  </ul>
                </li>
              </ol>
            </section>
            <!-- end section -->

            <section id="line10" class="section">
              <div class="row">
                <div class="col-md-12 left-align">
                  <h2 class="dark-text">
                    CI/CD
                    <hr />
                  </h2>
                </div>
                <!-- end col -->
              </div>
              <h4 id="line7_1">Placeholder</h4>
              <p>Placeholder</p>
            </section>
            <!-- end section -->

            <section id="line11" class="section">
              <div class="row">
                <div class="col-md-12 left-align">
                  <h2 class="dark-text">
                    Copyright and license
                    <hr />
                  </h2>
                </div>
                <!-- end col -->
              </div>
              <!-- end row -->

              <div class="row">
                <div class="col-md-12">
                  <p>
                    Code released under the
                    <a href="#" target="_blank">Un License</a> License.
                  </p>
                  <p>
                    For more information about copyright and license check
                    <a
                      href=" https://choosealicense.com/licenses/unlicense/"
                      target="_blank"
                      >choosealicense.com</a
                    >.
                  </p>
                </div>
              </div>
              <!-- end row -->
            </section>
            <!-- end section -->
          </div>
          <!-- // end .col -->
        </div>
        <!-- // end .row -->
      </div>
      <!-- // end container -->
    </div>
    <!-- end wrapper -->

    <script src="js/jquery.min.js"></script>
    <script src="js/bootstrap.min.js"></script>
    <script src="js/retina.js"></script>
    <script src="js/jquery.fitvids.js"></script>
    <script src="js/wow.js"></script>
    <script src="js/jquery.prettyPhoto.js"></script>

    <!-- CUSTOM PLUGINS -->
    <script src="js/custom.js"></script>
    <script src="js/main.js"></script>

    <script src="js/syntax-highlighter/scripts/shCore.js"></script>
    <script src="js/syntax-highlighter/scripts/shBrushXml.js"></script>
    <script src="js/syntax-highlighter/scripts/shBrushPython.js"></script>
    <script src="js/syntax-highlighter/scripts/shBrushBash.js"></script>
    <script src="js/syntax-highlighter/scripts/shBrushJScript.js"></script>
  </body>
</html>
